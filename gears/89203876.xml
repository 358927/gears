<Item class="Model" referent="RBXB7986878489E4C22BCA1FB542684D231">
			<Properties>
				<BinaryString name="AttributesSerialize" />
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">89203876</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags" />
				<OptionalCoordinateFrame name="WorldPivotData" />
			</Properties>
			<Item class="Tool" referent="RBXF99FFF319FF5459DB6A7399CD23C9AF0">
				<Properties>
					<BinaryString name="AttributesSerialize" />
					<bool name="CanBeDropped">false</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>-1</R00>
						<R01>0</R01>
						<R02>-8.74227766e-08</R02>
						<R10>-8.74227766e-08</R10>
						<R11>-4.37113883e-08</R11>
						<R12>1</R12>
						<R20>-3.82137093e-15</R20>
						<R21>1</R21>
						<R22>4.37113883e-08</R22>
					</CoordinateFrame>
					<token name="LevelOfDetail">0</token>
					<bool name="ManualActivationOnly">false</bool>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">CelestialStaff</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<bool name="RequiresHandle">true</bool>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags" />
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=84102386</url></Content>
					<string name="ToolTip" />
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-0.5</X>
							<Y>2.30000019</Y>
							<Z>-0.5</Z>
							<R00>-0</R00>
							<R01>-1</R01>
							<R02>0</R02>
							<R10>-0</R10>
							<R11>-0</R11>
							<R12>1</R12>
							<R20>-1</R20>
							<R21>-0</R21>
							<R22>0</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBX0A36E9EB0BD54C9F9D497B9CFC86F86A">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize" />
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-0.5</X>
							<Y>2.30000019</Y>
							<Z>-0.5</Z>
							<R00>-0</R00>
							<R01>-1</R01>
							<R02>0</R02>
							<R10>-0</R10>
							<R11>-0</R11>
							<R12>1</R12>
							<R20>-1</R20>
							<R21>-0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized" />
						<string name="Name">Handle</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>1</X>
							<Y>1</Y>
							<Z>4.5</Z>
						</Vector3>
					</Properties>
					<Item class="SpecialMesh" referent="RBX018CF4133D6C4CF381C9D8221904CB9B">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="MeshId"><url>http://www.roblox.com/asset/?id=84102534</url></Content>
							<token name="MeshType">5</token>
							<string name="Name">Mesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>1.5</X>
								<Y>1.5</Y>
								<Z>1.5</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<Content name="TextureId"><url>http://www.roblox.com/asset/?id=84102498</url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX4F1E6B4E40BD47F6BC4B0AE6B6F175F9">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">Main</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{F1182168-3833-47E4-9016-98E8B08DF834}</string>
						<ProtectedString name="Source">local function class(name)
	local def = {}
	getfenv(0)[name] = def
	return function(ctor, static)
		local nctor = function(...)
			local this = {}
			if ctor then
				ctor(this, ...)
			end
			return this
		end
		getfenv(0)['Create'..name] = nctor
		if static then static(def) end
	end
end

local function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

--[[----------------------------------------------------------------------------
AnimationProvider
	Manages animations.

	CreateAnimationProvider(animations)
		Returns a new AnimationProvider instance.
		`animations` is a table containing identity/asset_id pairs.
		`asset_id` may be a string (Content) or an integer.
	AnimationProvider:LoadHumanoid(humanoid)
		Loads the animations into `humanoid`.
	AnimationProvider:GetAnimation(identity)
		Returns an AnimationTrack.
		May only be called after LoadHumanoid.
	AnimationProvider:StopAnimations()
		Stops all animations.
		May only be called after LoadHumanoid.
]]
class'AnimationProvider'(function(def,anim_ids)
	local animations = {}
	local animationTracks = {}
	local catcherCallbacks = {}
	local keyframeCatchers = {}
	local workingHumanoid

	for name,id in pairs(anim_ids) do
		animations[name] = Create'Animation'{
			Name = name;
			AnimationId = type(id) == "number" and ("rbxassetid://"..id) or id;
			Archivable = false;
		}
	end

	function def:LoadHumanoid(humanoid)
		if humanoid ~= workingHumanoid then
			workingHumanoid = humanoid
			for name,anim in pairs(animations) do
				local old_track = animationTracks[name]
				if old_track then
					old_track:Stop()
					old_track:Destroy()
					if keyframeCatchers[name] then
						keyframeCatchers[name] = nil
					end
				end

				local track = humanoid:LoadAnimation(anim)
				animationTracks[name] = track
				if catcherCallbacks[name] then
					local catcher = CreateKeyframeCatcher(track)
					keyframeCatchers[name] = catcher
					catcher:SetCallbacks(catcherCallbacks[name])
				end
			end
		end
	end

	function def:GetAnimation(name)
		if not workingHumanoid then
			error("GetAnimation: humanoid has not been loaded",2)
		end
		return animationTracks[name]
	end

	function def:StopAnimations()
		for name,track in pairs(animationTracks) do
			track:Stop()
		end
	end

	-- lazy get
	setmetatable(def,{__index = animationTracks})
end)


--[[
SoundProvider
	Manages sounds.

	CreateSoundProvider(sounds)
		Returns a new SoundProvider.
		`sounds` is a table containing identity/asset_id pairs.
		`asset_id` may be a string (Content) or an integer.
	SoundProvider:SetParent(parent)
		Sets the parent of all the sounds at once. Can be nil.
	SoundProvider:GetSound(identity)
		Returns a Sound.
	SoundProvider:StopSounds()
		Stops all sounds.
	SoundProvider:Fade(identity, goal, time, delta)
		Applies a fading effect to a Sound, starting with the current volume.
		`goal` is the volume to reach by the end of the transition.
		`time` is the amount of time the transition should take, in seconds.
		Optionally, `delta` is a function that transforms the progress of the fade (for non-linear transitions)
]]
class'SoundProvider'(function(def,sound_ids)
	local sounds = {}

	local CP = Game:GetService("ContentProvider")

	for name,id in pairs(sound_ids) do
		sounds[name] = Create'Sound'{
			Name = name;
			SoundId = type(id) == "number" and ("rbxassetid://"..id) or id;
			Archivable = false;
		}
		CP:Preload(sounds[name].SoundId)
	end

	function def:SetParent(parent)
		for name,sound in pairs(sounds) do
			sound.Parent = parent
		end
	end

	function def:GetSound(name)
		return sounds[name]
	end

	function def:StopSounds()
		for name,sound in pairs(sounds) do
			sound:Stop()
		end
	end

	function def:Fade(name,g,t,delta)
		local sound = sounds[name]
		delta = delta or function(n) return n end
		if sound then
			local s = sound.Volume
			local i = 0
			while i &lt; 1 do
				i = i + wait()/t
				sound.Volume = (g-s)*delta(i)+s
			end
			sound.Volume = g
		else
			error("SoundProvider::Fade: no such sound named `"..name.."`",2)
		end
	end

	-- lazy get
	setmetatable(def,{__index = sounds})
end)

--[[
ThreadID
	Makes sure new threads override old ones.

	CreateThreadID()
		Returns a new ThreadID.
	ThreadID:Request()
		Returns a new ID and increments the current one.
	ThreadID:Assert(id)
		Returns whether the thread's ID equals the current one.
	ThreadID:Reset()
		Reset the current ID.
]]
class'ThreadID'(function(def)
	local thread_id = 0

	function def:Assert(id)
		return thread_id == id
	end

	function def:Request()
		thread_id = thread_id + 1
		return thread_id
	end

	function def:Reset()
		thread_id = 0
	end
end)

--[[
	WalkSpeedManager
		Manages a Humanoid's WalkSpeed.
		When the walkspeed is set externally (not by this instance), the new value will become the base walkspeed.
		However, the walkspeed can be locked. If so, the walkspeed will be reverted if it has been changed externally.
		This allows the tool to be compatible with, say, a speed potion.

	CreateWalkSpeedManager()
		Returns a new WalkSpeedManager.
	WalkSpeedManager:SetHumanoid(humanoid)
		Sets the humanoid and sets its WalkSpeed as the base.
	WalkSpeedManager:Set(walkspeed)
		Sets and locks the humanoid's walkspeed.
	WalkSpeedManager:Reset()
		Unlocks and resets the humanoid's walkspeed to the base walkspeed.
	WalkSpeedManager:GetBase()
		Returns the base walkspeed.
]]
class'WalkSpeedManager'(function(def)
	local baseWalkSpeed = 16
	local currentWalkSpeed = 16
	local locked = false
	local settingInternal = false
	local humanoid
	local changed

	function def:SetHumanoid(hum)
		humanoid = hum
		locked = false
		if changed then changed:disconnect() end
		if hum then
			baseWalkSpeed = hum.WalkSpeed
			currentWalkSpeed = baseWalkSpeed
			changed = hum.Changed:connect(function(p)
				if p == "WalkSpeed" and not settingInternal then
					-- something external is modifying the walkspeed; use that as the base
					baseWalkSpeed = hum.WalkSpeed
					if locked then
						settingInternal = true
						hum.WalkSpeed = currentWalkSpeed
						settingInternal = false
					end
				end
			end)
		end
	end

	function def:Set(ws)
		if humanoid then
			locked = true
			currentWalkSpeed = ws
			settingInternal = true
			humanoid.WalkSpeed = ws
			settingInternal = false
		end
	end

	function def:Reset()
		if humanoid then
			currentWalkSpeed = baseWalkSpeed
			settingInternal = true
			humanoid.WalkSpeed = baseWalkSpeed
			settingInternal = false
			locked = false
		end
	end

	function def:GetBase()
		return baseWalkSpeed
	end
end)

--[[
LightingTime
	Manages lighting transition.

	CreateLightingTime ( number `acceleration`, number `deceleration`, number `max_velocity` )
		All three arguments measure in hours.
	:Start ( ThreadID `thread`, number `currentID` )
		Starts up the transition with `thread` and `currentID` to determine whether to accelerate or decelerate.
	:Stop ( )
		Immediately stops the transition.
	:GetExternalCount ( )
		Returns the amount of times the TimeOfDay has been changed externally.
	:ResetExternalCount ( )
		Reset external change count.

]]
class'LightingTime'(function(def,accel,decel,max)
	-- convert number (in hours) to TimeOfDay string
	-- because TimeOfDay doesn't cast numbers as expected (3.7 -&gt; 03:07:00 instead of 3:42:00)
	local function ToTimeOfDay(n)
		n = n % 24
		local i,f = math.modf(n)
		local m = f*60
		local mi,mf = math.modf(m)
		m = tostring(math.abs(math.floor(m)))
		local s = tostring(math.abs(math.floor(mf*60)))
		return i..":"..string.rep("0",2-#m)..m..":"..string.rep("0",2-#s)..s
	end

	-- convert TimeOfDay string to number (in hours)
	local function FromTimeOfDay(t)
		local signed,h,m,s = t:match("^(%-?)(%d+):(%d+):(%d+)$")
		s = tonumber(s)/60
		m = tonumber(m + s)/60
		h = tonumber(h) + m
		return h * (#signed &gt; 0 and -1 or 1)
	end

	local Lighting = Game:GetService("Lighting")
	local threadRunning = false
	local setInternal = false
	local time = FromTimeOfDay(Lighting.TimeOfDay)
	local velocity = 0
	local exCount = 0
	local threadID
	local cID

	max = max * 0.03

	local con = Lighting.Changed:connect(function(p)
		if p == "TimeOfDay" then
			if not setInternal then
				exCount = exCount + 1
				threadRunning = false
			end
		end
	end)

	function def:Reset()
		setInternal = false
		velocity = 0
	end

	function def:ResetExternalCount()
		exCount = 0
	end

	function def:GetExternalCount()
		return exCount
	end

	local function NewThread()
		coroutine.wrap(function()
			threadRunning = true
			time = FromTimeOfDay(Lighting.TimeOfDay)
			while threadRunning do
				local t = wait()
				if threadID:Assert(cID) then
					velocity = velocity + accel*t
				else
					velocity = velocity - accel*t
				end
				if velocity &gt; max then
					velocity = max
				elseif velocity &lt; 0 then
					threadRunning = false
					break
				end

				time = time + velocity

				setInternal = true
				Lighting.TimeOfDay = ToTimeOfDay(time)
				setInternal = false
			end
			def:Reset()
		end)()
	end

	function def:Start(thread,cid)
		threadID = thread
		cID = cid
		if not threadRunning then
			NewThread()
		end
	end

	function def:Stop()
		threadRunning = false
	end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- Tiny Event Manager; Add: [[Event.EventName = (event)]]; Remove: [[Disconnect("EventName",...)]]
local Event = {}
local function Disconnect(...)
	for _,name in pairs{...} do
		if Event[name] then
			Event[name]:disconnect()
			Event[name] = nil
		end
	end
end

-- get an object; make it if it doesn't exist
local function GetMake(parent,name,type)
	local object = parent:FindFirstChild(name)
	if not object then
		object = Create(type){Name=name}
		object.Parent = parent
	end
	return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
	while not parent:FindFirstChild(name) do
		parent.ChildAdded:wait()
	end
	return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
	if object and object.Parent then
		for i,v in pairs(object.Parent:GetChildren()) do
			if v:IsA"Humanoid" then
				return v
			end
		end
	end
	return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
	local humanoid = GetHumanoid(object)
	if humanoid then
		return object.Parent,humanoid
	end
	return nil
end

-- make a joint, if the objects exist
local function AttemptJoint(x,y,c0,c1)
	if x and y then
		local weld = Instance.new("Motor6D")
		weld.Part0 = x
		weld.Part1 = y
		if c0 then weld.C0 = c0 end
		if c1 then weld.C1 = c1 end
		weld.Parent = x
		return weld
	end
end

-- destroy a joint used only by the two objects
local function KillJoint(x,y)
	if x and y then
		for i,v in pairs(x:GetChildren()) do
			if v:IsA"Motor6D" then
				if v.Part0 == x and v.Part1 == y then
					v:Destroy()
				end
			end
		end
	end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--SETTINGS----------------------------------------------------------------------

-- Time velocity when transitioning
local time_acceleration	= ( 1/2 )*1/60	-- minutes per second
local time_deceleration	= ( 1 )*1/60	-- minutes per second
local max_time_velocity	= ( 1/2 )		-- hours per second

-- Magic circle shield
local charge_time	= 1		-- amount of time before circle is fully charged
local decharge_time	= 0.5	-- amount of time before circle is completely decharged
local spin_velocity	= 90	-- degrees per second
local circle_size	= 24	-- max diameter of circle

-- Missiles
local missile_range	= 48	-- range in which humanoids will be detected
							-- size == [n, volume_limit/(n*n), n]/2
local missile_delay	= 0.5	-- the amount of time (in seconds) between each missile
local missile_speed	= 24

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Tool = script.Parent
local Handle = WaitForChild(Tool,"Handle")
local Character,Humanoid

local magicEnabled = true
local canMagic = true

local BurnScript = WaitForChild(Tool,"BurnScript")
local BindScript = WaitForChild(Tool,"BindScript")

local ShieldActive = GetMake(Tool,"ShieldActive","BoolValue")
ShieldActive.Value = false

local WalkSpeed = CreateWalkSpeedManager()

local Animation = CreateAnimationProvider{
	Wave	= "http://www.roblox.com/asset/?id=83994332";
	Raised	= "http://www.roblox.com/asset/?id=83994319";
}

local Sound = CreateSoundProvider{
	SunBurst	= "http://www.roblox.com/asset/?id=16433289";
	MoonBurst	= "http://www.roblox.com/asset/?id=84005018";
}

local CircleTemplate = Create'Part'{
	Name = "CelestialCircle";
	Anchored = true;
	CanCollide = false;
	Transparency = 1;
	FormFactor = Enum.FormFactor.Custom;
	TopSurface = Enum.SurfaceType.Smooth;
	BottomSurface = Enum.SurfaceType.Smooth;
	Create'Decal'{
		Name = "DecalTop";
		Face = Enum.NormalId.Top;
		Texture = "http://www.roblox.com/asset/?id=78036587";
	};
	Create'Decal'{
		Name = "DecalBottom";
		Face = Enum.NormalId.Bottom;
		Texture = "http://www.roblox.com/asset/?id=78036587";
	};
	Create'BlockMesh'{
		Scale = Vector3.new(1,0,1);
	};
};

-- if theres a character, get a body part from it
local function GetBodyPart(name)
	local character = Character or GetCharacter(Tool)
	if character then
		local object = character:FindFirstChild(name)
		if object then
			return object
		end
	end
	return nil
end

local LightingTime = CreateLightingTime(time_acceleration,time_deceleration,max_time_velocity)

local Missiles = {
	{	-- moon
		is_active = function()
			return Game:GetService("Lighting"):GetMoonDirection():Dot(Vector3.new(0,1,0)) &gt; 0;
		end;
		fire = function(origin,target)
			local missile = Create'Part'{
				Name = "CelestialMissile";
				FormFactor = 0;
				TopSurface = 0;
				BottomSurface = 0;
				Reflectance = 0.5;
				BrickColor = BrickColor.new("Bright yellow");
				CanCollide = false;
				Locked = true;
				Size = Vector3.new(4,4,1);
				Create'SpecialMesh'{
					MeshId = "http://www.roblox.com/asset/?id=3270017";
					Scale = Vector3.new(4,4,4);
				};
				Create'Sparkles'{
					SparkleColor = Color3.new(1,1,0);
				};
				Create'BodyVelocity'{
					maxForce = Vector3.new(math.huge,math.huge,math.huge);
					velocity = Vector3.new(0,0,0);
				};
				Create'Sound'{
					SoundId = Sound.MoonBurst.SoundId;
				};
			}
			local bv = missile.BodyVelocity
			local particle = missile.Sparkles
			missile.CFrame = CFrame.new(origin,target) --* CFrame.Angles(-math.pi/2,0,0)
			bv.velocity = (target-origin).unit*missile_speed
			local con;con = missile.Touched:connect(function(hit)
				if not hit:IsDescendantOf(Character) and hit.Name ~= "CelestialMissile" then
					local h = GetHumanoid(hit)
					if h and h.Health &gt; 0 and h.Torso then
						local bind = BindScript:Clone()
						bind.Disabled = false
						bind.Parent = h.Torso
					end
					con:disconnect()
					missile.Anchored = true
					missile.Transparency = 1
					particle.Enabled = false
					wait(1) -- particles cut off if Fire object is removed, which looks ugly
					missile:Destroy()
				end
			end)
			local sound = missile.Sound
			missile.Parent = Workspace
			sound:Play()
			Game:GetService("Debris"):AddItem(missile,5)
		end;
	};
	{	-- sun
		is_active = function()
			return Game:GetService("Lighting"):GetSunDirection():Dot(Vector3.new(0,1,0)) &gt; 0;
		end;
		fire = function(origin,target)
			local missile = Create'Part'{
				Name = "CelestialMissile";
				FormFactor = 0;
				Shape = 0;
				TopSurface = 0;
				BottomSurface = 0;
				Transparency = 0.5;
				BrickColor = BrickColor.new("Deep orange");
				CanCollide = false;
				Locked = true;
				Size = Vector3.new(3,3,3);
				Create'Fire'{};
				Create'BodyVelocity'{
					maxForce = Vector3.new(math.huge,math.huge,math.huge);
					velocity = Vector3.new(0,0,0);
				};
				Create'Sound'{
					SoundId = Sound.SunBurst.SoundId;
				};
			}
			local bv = missile.BodyVelocity
			local particle = missile.Fire
			missile.CFrame = CFrame.new(origin,target) * CFrame.Angles(-math.pi/2,0,0)
			bv.velocity = (target-origin).unit*missile_speed
			local con;con = missile.Touched:connect(function(hit)
				if not hit:IsDescendantOf(Character) and hit.Name ~= "CelestialMissile" then
					if GetHumanoid(hit) then
						local burn = BurnScript:Clone()
						burn.Disabled = false
						burn.Parent = hit
					end
					con:disconnect()
					missile.Anchored = true
					missile.Transparency = 1
					particle.Enabled = false
					wait(1) -- particles cut off if Fire object is removed, which looks ugly
					missile:Destroy()
				end
			end)
			local sound = missile.Sound
			missile.Parent = Workspace
			sound:Play()
			Game:GetService("Debris"):AddItem(missile,5)
		end;
	};
}

local function FireMissiles(origin)

	-- get missiles that are active
	local activeMissiles = {}
	for i = 1,#Missiles do
		local missile = Missiles[i]
		if missile.is_active() then
			activeMissiles[#activeMissiles+1] = missile.fire
		end
	end
	if #activeMissiles == 0 then return end

	local humanoidList = {}
	do	-- get a list of humanoids within a region
		local region_vec = Vector3.new(missile_range,math.floor(10^5/(missile_range*missile_range)),missile_range)/2
		local missile_region = Region3.new(origin-region_vec,origin+region_vec)
		local partsList = Workspace:FindPartsInRegion3(missile_region,Character,100)
		local parentCache = {}
		for i,part in pairs(partsList) do
			local parent = part.Parent
			if not parentCache[parent] then
				parentCache[parent] = true
				local h = GetHumanoid(part)
				if h and h.Health &gt; 0 then
					humanoidList[#humanoidList+1] = h
				end
			end
		end
	end
	if #humanoidList == 0 then return end

	-- randomize humanoid list
	for i = 1,#humanoidList do
		local r = math.random(1,#humanoidList)
		humanoidList[i],humanoidList[r] = humanoidList[r],humanoidList[i]
	end

	-- fire random missile in each humanoid's direction
	for i = 1,#humanoidList do
		local humanoid = humanoidList[i]
		local pos
		do
			local target = humanoid.Torso
			if target then
				pos = target.Position
			end
		end
		if pos then
			local missile = activeMissiles[math.random(1,#activeMissiles)]
			coroutine.wrap(missile)(origin,pos)
			wait(missile_delay)
		end
	end
end

local ClickThread = CreateThreadID()
Tool.Equipped:connect(function(Mouse)
	Character,Humanoid = GetCharacter(Tool)
	if not Character then return end
	Animation:LoadHumanoid(Humanoid)
	WalkSpeed:SetHumanoid(Humanoid)

	local Torso = GetBodyPart("Torso")

	do	-- replace the interfering RightGrip joint
		local RightArm = GetBodyPart("Right Arm")
		if RightArm then
			local grip = WaitForChild(RightArm,"RightGrip")
			local C0,C1 = grip.C0,grip.C1
			wait()
			AttemptJoint(RightArm,Handle,C0,C1)
		end
	end

	local down = false
	Mouse.Button1Down:connect(function()
		if canMagic and GetBodyPart("Right Arm") then
---- READY MAGIC
			local cid = ClickThread:Request()

			LightingTime:ResetExternalCount()

			Animation.Raised:Play(0.25)
			wait(0.25)
			if not ClickThread:Assert(cid) then return end
			Animation.Wave:Play()
			wait(0.2)
			if not ClickThread:Assert(cid) then return end

---- DO MAGIC
			canMagic = false
			WalkSpeed:Set(0)

			if LightingTime:GetExternalCount() == 0 then
				LightingTime:Start(ClickThread,cid)
			end

			local Circle = CircleTemplate:Clone()
			Circle.Size = Vector3.new(circle_size,16,circle_size)
			Circle.Parent = Character
			local top = Circle.DecalTop
			local bottom = Circle.DecalBottom
			local pos = Circle.Position
			local charge,spin = 0,0
			while ClickThread:Assert(cid) do
				local t = wait()
				charge = charge + t/charge_time
				if charge &gt;= 1 then
					charge = 1
					ShieldActive.Value = true
				else
					ShieldActive.Value = false
				end
				spin = spin + spin_velocity*t
				local c = 1-math.pow(1-charge,2)
				Circle.Mesh.Scale = Vector3.new(c,0,c)
				top.Transparency = 1-c
				bottom.Transparency = 1-c
				Circle.CFrame = CFrame.new(Torso.Position+Vector3.new(0,-2,0)) * CFrame.Angles(0,-math.rad(spin),0)
			end

---- FIRE MISSILES
			if charge &gt;= 1 then
				Spawn(function()
					FireMissiles(Torso.Position)
					WalkSpeed:Reset()
					canMagic = true
				end)
			else
				WalkSpeed:Reset()
				canMagic = true
			end

---- CLEANUP MAGIC
			ShieldActive.Value = false

			local pos = Circle.Position
			local size = Circle.Mesh.Scale.x
			local opac = 1-top.Transparency
			charge = 1
			ShieldActive.Value = false
			while charge &gt; 0 do
				local t = wait()
				charge = charge - t/decharge_time
				spin = spin + spin_velocity*t
				local c = (1-math.pow(1-charge,2))*size
				Circle.Mesh.Scale = Vector3.new(c,0,c)
				top.Transparency = 1-charge*opac
				bottom.Transparency = 1-charge*opac
				Circle.CFrame = CFrame.new(pos) * CFrame.Angles(0,-math.rad(spin),0)
			end
			Circle:Destroy()
		end
	end)

	Mouse.Button1Up:connect(function()
		local cid = ClickThread:Request()
		Animation.Wave:Stop(0.1)
		wait(0.1)
		if not ClickThread:Assert(cid) then return end
		Animation.Raised:Stop()
	end)
end)

Tool.Unequipped:connect(function()
	ShieldActive.Value = false
	KillJoint(GetBodyPart("Right Arm"),Handle)
	ClickThread:Reset()
	Animation:StopAnimations()
	Sound:StopSounds()
	WalkSpeed:Reset()
end)

</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBXBB9945934D064497AE52BE63862901BC">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">Damage</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{AA49AE1F-18E1-47BC-B699-3DAA93575FC1}</string>
						<ProtectedString name="Source">local function class(name)
	local def = {}
	getfenv(0)[name] = def
	return function(ctor, static)
		local nctor = function(...)
			local this = {}
			if ctor then
				ctor(this, ...)
			end
			return this
		end
		getfenv(0)['Create'..name] = nctor
		if static then static(def) end
	end
end

local function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

--[[
	DamageReducer
		Reduces damage taken to humanoid by a specified percentage.

	CreateDamageReducer()
		Returns a new DamageReducer.
	DamageReducer:SetHumanoid(humanoid)
		Sets the humanoid. `humanoid` can be nil.
	DamageReducer:SetActive(active)
		Sets whether the damage reducer is active.
	DamageReducer:SetReduction(pct)
		Sets the amount of damage reduction as a percentage.
]]
class'DamageReducer'(function(def)
	local reduction = 0
	local active = false
	local humanoid
	local changed

	local function disconnect_changed()
		if changed then
			changed:disconnect()
			changed = nil
		end
	end

	local function connect_changed()
		if humanoid then
			disconnect_changed()
			local e = true
			local last_health = humanoid.Health
			changed = humanoid.HealthChanged:connect(function(health)
				if e then
					e = false
					if health &lt; last_health then
						local damage = math.abs(health - last_health)
						humanoid.Health = health + damage*reduction
					end
					e = true
				end
				last_health = humanoid.Health
			end)
		end
	end

	function def:SetHumanoid(h)
		humanoid = h
		if h and active then
			connect_changed()
		end
	end

	function def:SetReduction(pct)
		reduction = pct &lt; 0 and 0 or pct &gt; 1 and 1 or pct
	end

	function def:SetActive(a)
		active = a
		if a then
			connect_changed()
		else
			disconnect_changed()
		end
	end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- get an object; make it if it doesn't exist
local function GetMake(parent,name,type)
	local object = parent:FindFirstChild(name)
	if not object then
		object = Create(type){Name=name}
		object.Parent = parent
	end
	return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
	while not parent:FindFirstChild(name) do
		parent.ChildAdded:wait()
	end
	return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
	if object and object.Parent then
		for i,v in pairs(object.Parent:GetChildren()) do
			if v:IsA"Humanoid" then
				return v
			end
		end
	end
	return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
	local humanoid = GetHumanoid(object)
	if humanoid then
		return object.Parent,humanoid
	end
	return nil
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Players = Game:GetService("Players")
local Debris = Game:GetService("Debris")

local Tool = script.Parent
local Handle = WaitForChild(Tool,"Handle")
local BurnScript = Tool:FindFirstChild("BurnScript")
local ShieldActive = WaitForChild(Tool,"ShieldActive")

local DamageReducer = CreateDamageReducer()
DamageReducer:SetReduction(0.5)

ShieldActive.Changed:connect(function(value)
	DamageReducer:SetActive(value)
end)

Tool.Equipped:connect(function()
	local Character,Humanoid = GetCharacter(Tool)
	local Player = Players:GetPlayerFromCharacter(Character)

	BurnScript = Tool:FindFirstChild("BurnScript")
	if BurnScript then
		local ctag = GetMake(BurnScript,"creator","ObjectValue")
		ctag.Value = Player
	end

	DamageReducer:SetHumanoid(Humanoid)
end)

Tool.Unequipped:connect(function()
	DamageReducer:SetHumanoid()
end)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBX2897359F540D499B87D14709F083BC04">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">BurnScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{5C5604D0-F03A-42AE-8F5C-3FBCB2ECDBD8}</string>
						<ProtectedString name="Source">local damage = 2
local interval = 0.5

local Debris = Game:GetService("Debris")
local BodyPart = script.Parent
local Humanoid
do
	if BodyPart.Parent then
		for i,v in pairs(BodyPart.Parent:GetChildren()) do
			if v:IsA"Humanoid" then
				Humanoid = v
				break
			end
		end
	end
end

if Humanoid then
	local Fire = Instance.new("Fire",BodyPart)
	script.Parent = Fire

	local died = false
	Humanoid.Died:connect(function() died = true end)

	local CreatorTag = script:FindFirstChild("creator")
	if CreatorTag then
		CreatorTag = CreatorTag:Clone()
		while not died do
			local ctag = CreatorTag:Clone()
			ctag.Parent = Humanoid
			Humanoid:TakeDamage(damage)
			Debris:AddItem(ctag,interval)
			wait(interval)
		end
	else
		while not died do
			Humanoid:TakeDamage(damage)
			wait(interval)
		end
	end
end
script:Destroy()</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBX0E0B062E86B34BC287B5D7C5C17B05E8">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">BindScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{890CBA7A-7234-4620-9DDF-D6F7BC44D398}</string>
						<ProtectedString name="Source">local bind_time = 5

local Debris = Game:GetService("Debris")
local BodyPart = script.Parent
local Humanoid
do
	if BodyPart.Parent then
		for i,v in pairs(BodyPart.Parent:GetChildren()) do
			if v:IsA"Humanoid" then
				Humanoid = v
				break
			end
		end
	end
end

if Humanoid then
	local oWalkSpeed = Humanoid.WalkSpeed
	Humanoid.WalkSpeed = 0

	local bind0 = Instance.new("Part")
	bind0.Name = "CelestialMissile"
	bind0.FormFactor = 0
	bind0.TopSurface = 0
	bind0.BottomSurface = 0
	bind0.Reflectance = 0.5
	bind0.BrickColor = BrickColor.new("Bright yellow")
	bind0.Anchored = true
	bind0.CanCollide = false
	bind0.Locked = true
	bind0.Size = Vector3.new(4,4,1)
		local mesh = Instance.new("SpecialMesh",bind0)
		mesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
		mesh.Scale = Vector3.new(4,4,4)
	local bind1 = bind0:Clone()
		local p = Instance.new("Sparkles",bind1)
		p.SparkleColor = Color3.new(1,1,0)
	bind0.Parent = script
	bind1.Parent = script

	local start = tick()
	local spin = 0
	while script.Parent do
		bind0.CFrame = BodyPart.CFrame * CFrame.Angles(math.rad(spin),-math.rad(spin*2),math.rad(spin))
		bind1.CFrame = BodyPart.CFrame * CFrame.Angles(-math.rad(spin),math.rad(spin),math.rad(spin))
		spin = spin + 90*wait()
		if tick()-start &gt; bind_time then break end
	end
	for i=0,1,0.1 do
		bind0.Transparency = i
		bind1.Transparency = i
		bind0.CFrame = BodyPart.CFrame * CFrame.Angles(math.rad(spin),-math.rad(spin*2),math.rad(spin))
		bind1.CFrame = BodyPart.CFrame * CFrame.Angles(-math.rad(spin),math.rad(spin),math.rad(spin))
		spin = spin + 90*wait()
	end
	Humanoid.WalkSpeed = oWalkSpeed &gt; 0 and oWalkSpeed or 16
	bind0:Destroy()
	bind1:Destroy()
end
script:Destroy()</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Camera" referent="RBX49B392FBC7784550A921E0957B8B7899">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<CoordinateFrame name="CFrame">
							<X>4.2886734</X>
							<Y>2.05584955</Y>
							<Z>-2.04162693</Z>
							<R00>-0.328868985</R00>
							<R01>0.181813791</R01>
							<R02>0.926708698</R02>
							<R10>3.72528985e-09</R10>
							<R11>0.981292486</R11>
							<R12>-0.192522764</R12>
							<R20>-0.944375515</R20>
							<R21>-0.0633147657</R21>
							<R22>-0.322716683</R22>
						</CoordinateFrame>
						<Ref name="CameraSubject">null</Ref>
						<token name="CameraType">0</token>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="FieldOfView">70</float>
						<token name="FieldOfViewMode">0</token>
						<CoordinateFrame name="Focus">
							<X>-14.2455025</X>
							<Y>5.90630531</Y>
							<Z>4.41270781</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="HeadLocked">true</bool>
						<float name="HeadScale">1</float>
						<string name="Name">ThumbnailCamera</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<bool name="VRTiltAndRollEnabled">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		