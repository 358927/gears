<Item class="Model" referent="RBX0DF807BFB8A141628FC2BA1D58036652">
			<Properties>
				<BinaryString name="AttributesSerialize" />
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">181245120</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags" />
				<OptionalCoordinateFrame name="WorldPivotData" />
			</Properties>
			<Item class="Tool" referent="RBXB12BE286DB4A4EB2BDD1486A4BD8823E">
				<Properties>
					<BinaryString name="AttributesSerialize" />
					<bool name="CanBeDropped">false</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>0.349999994</X>
						<Y>-0.5</Y>
						<Z>0.699999988</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<token name="LevelOfDetail">0</token>
					<bool name="ManualActivationOnly">false</bool>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">CandyBomb</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<bool name="RequiresHandle">true</bool>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags" />
					<Content name="TextureId"><url>http://www.roblox.com/asset?id=179628862</url></Content>
					<string name="ToolTip">Candy Bomb</string>
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>1.20500016</X>
							<Y>4.0999999</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBXA5DE46AEF4F84AC2980C1D77BB2E3897">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize" />
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>1.20500016</X>
							<Y>4.0999999</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized" />
						<string name="Name">Handle</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">0</token>
						<token name="shape">0</token>
						<Vector3 name="size">
							<X>1.38999987</X>
							<Y>1.38999987</Y>
							<Z>1.38999987</Z>
						</Vector3>
					</Properties>
					<Item class="SpecialMesh" referent="RBX7BFD9B2AEA124814996B523930A63B7D">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="MeshId"><url>http://www.roblox.com/asset?id=179628795</url></Content>
							<token name="MeshType">5</token>
							<string name="Name">Mesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<Content name="TextureId"><url>http://www.roblox.com/asset?id=179628830</url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBX79AADF1D3B2C4520B12873F1E5B3502A">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="IsMutedForCapture">false</bool>
							<NumberRange name="LoopRegion">0 60000 </NumberRange>
							<bool name="Looped">false</bool>
							<string name="Name">Boom</string>
							<bool name="PlayOnRemove">false</bool>
							<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
							<bool name="PlaybackRegionsEnabled">false</bool>
							<float name="PlaybackSpeed">1</float>
							<bool name="Playing">false</bool>
							<float name="RollOffMaxDistance">10000</float>
							<float name="RollOffMinDistance">10</float>
							<token name="RollOffMode">0</token>
							<Ref name="SoundGroup">null</Ref>
							<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<double name="TimePosition">0</double>
							<float name="Volume">1</float>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBX0AD93EE0CCC745F6AD2036D442F72075">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="IsMutedForCapture">false</bool>
							<NumberRange name="LoopRegion">0 60000 </NumberRange>
							<bool name="Looped">false</bool>
							<string name="Name">Beep</string>
							<bool name="PlayOnRemove">false</bool>
							<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
							<bool name="PlaybackRegionsEnabled">false</bool>
							<float name="PlaybackSpeed">1</float>
							<bool name="Playing">false</bool>
							<float name="RollOffMaxDistance">10000</float>
							<float name="RollOffMinDistance">10</float>
							<token name="RollOffMode">0</token>
							<Ref name="SoundGroup">null</Ref>
							<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94137771</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<double name="TimePosition">0</double>
							<float name="Volume">1</float>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX917A9097ABEB4E698738D7B33ACE97D4">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">CandyBombLocalScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{4DE6E770-A1AB-4798-9F7C-003324A46FBB}</string>
						<ProtectedString name="Source">-- Made by SolarCrane

local RS = game:GetService('ReplicatedStorage')
local PlayersService = game:GetService("Players")

local Utility = require(RS:WaitForChild('Utility'))
local Signal = require(RS:WaitForChild('Signal'))
local CreateLocalWelder = require(RS:WaitForChild('LocalEquipWeld'))



local LocalPlayer = PlayersService.LocalPlayer
local Character = nil
local Tool = script.Parent
local Handle = Tool:WaitForChild('Handle')

local RequestShootServer = Tool:WaitForChild('RequestShootServer')

local COOLDOWN = 4 -- Seconds until tool can be used again
local TIME_BEFORE_RELEASE = 0.3

local ThrowAnimTrack = nil
local HoldAnimTrack = nil
local LastShot = 0
local Equipped = false

-- Code from http://www.miguelcasillas.com/?p=53
local function RayDistanceFromSphereSurface(tRay, sphereCenter, radius)
    -- Create a vector from the ray's start to the sphere's center
    local vecV1 = sphereCenter - tRay.Origin

    -- Project this vector onto the ray's direction vector
    local fD = vecV1:Dot(tRay.Direction.unit)

    -- If the ray is pointing away
    if fD &lt; 0 then
        return math.huge, math.rad(360)
	end

    -- Calculate the closest point to the sphere on the ray
    local vecClosestPoint = tRay.Origin + (tRay.Direction.unit * fD)

	local distanceToSphereSurface = math.max(0, ((sphereCenter - vecClosestPoint).magnitude - radius))

	local angle = math.acos((vecClosestPoint - tRay.Origin).unit:Dot(tRay.Direction.unit))
	if angle == nil then
		angle = math.rad(360)
	end
    return distanceToSphereSurface, angle
end


local function FindMonsterAlongRay(ray)
	local monstersByDistance = {}
	local monsterContainer = workspace:FindFirstChild("MonsterContainer")
	--local monsterContainer = workspace:FindFirstChild("TestDummies")
	if monsterContainer then
		for _, monster in pairs(monsterContainer:GetChildren()) do
			if monster:IsA('Model') then
				local monsterCFrame = monster:GetModelCFrame()
				local monsterSize = monster:GetExtentsSize()
				local distance, theta = RayDistanceFromSphereSurface(ray, monsterCFrame.p, math.min(math.min(monsterSize.X, monsterSize.Y), monsterSize.Z)) --monsterSize.magnitude)
				table.insert(monstersByDistance, {Monster = monster; Distance = distance; Theta = theta})
			end
		end
	end
	-- TODO: also sort by distance from player in this heuristic
	table.sort(monstersByDistance, function(a,b) return a['Distance'] &lt; b['Distance'] end)
	return monstersByDistance
end

local function GetShootOrigin()
	return Handle.CFrame.p
end

local function OnMouseDownChanged(down)
	--wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
	local now = tick()
	if now - LastShot &lt; COOLDOWN then
		return
	end
	if Equipped and Handle and Utility.CanFire(LocalPlayer) then
		if down then -- Player just clicked
			if HoldAnimTrack then
				HoldAnimTrack:Play(.1,1,1)
			end
		else -- Player just released click
			local humanoid = Utility.GetHumanoid(LocalPlayer)
			local targetPos = humanoid and humanoid.TargetPoint
			local shootOrigin = targetPos and GetShootOrigin(targetPos)
			local shootDirection = targetPos and shootOrigin and (targetPos - shootOrigin)

			if targetPos and shootOrigin and shootDirection then
				local shootRay = Ray.new(shootOrigin, shootDirection)

				local monsters = FindMonsterAlongRay(shootRay)
				local desiredShootTarget = monsters and monsters[1] and monsters[1]['Monster']
				local desiredShootTargetPos = desiredShootTarget and desiredShootTarget:GetModelCFrame().p

				if HoldAnimTrack then
					HoldAnimTrack:Stop()
				end
				if ThrowAnimTrack then
					ThrowAnimTrack:Play(0.1,1,0.75)
				end

				spawn(function()
					local projectile = RequestShootServer:InvokeServer(shootRay, tick() + (_G.ClientTimeDiff or 0), desiredShootTarget, desiredShootTargetPos)
				end)
			end
			LastShot = now
			Tool.Enabled = false
			delay(COOLDOWN - (tick() - LastShot), function()
				Tool.Enabled = true
			end)
		end
	end
end

local mouseButton1DownConn = nil
local mouseButton1UpConn = nil

local function DisconnectMouseEvents()
	if mouseButton1DownConn then
		mouseButton1DownConn:disconnect()
	end
	if mouseButton1UpConn then
		mouseButton1UpConn:disconnect()
	end
end

local function OnEquipped(mouse)
	Equipped = true
	local Character = LocalPlayer and LocalPlayer.Character
	DisconnectMouseEvents()
	mouseButton1DownConn = mouse.Button1Down:connect(function() OnMouseDownChanged(true) end)
	mouseButton1UpConn = mouse.Button1Up:connect(function() OnMouseDownChanged(false) end)
	local humanoid = Utility.GetHumanoid(LocalPlayer)
	if humanoid then
		local ThrowAnim = Tool:FindFirstChild('Throw')
		local HoldAnim = Tool:FindFirstChild('Hold')

		ThrowAnimTrack = ThrowAnim and humanoid:LoadAnimation(ThrowAnim)
		HoldAnimTrack = HoldAnim and humanoid:LoadAnimation(HoldAnim)
	end
end

local function OnUnequipped()
	Equipped = false
	OnMouseDownChanged(false)
	DisconnectMouseEvents()
	if HoldAnimTrack then
		HoldAnimTrack:Stop()
	end
	if ThrowAnimTrack then
		ThrowAnimTrack:Stop()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

CreateLocalWelder(Tool)

print"LocalBombLoaded"
</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBXBA298164050B4DD48C5911FCD87BEE8A">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">MouseIcon</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{6714F808-A95A-4B16-A71A-E40817686C6B}</string>
						<ProtectedString name="Source">local MOUSE_ICON = 'rbxasset://textures/GunCursor.png'
local RELOADING_ICON = 'rbxasset://textures/GunWaitCursor.png'

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
	Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
	Mouse = mouse
	UpdateIcon()
end

local function OnChanged(property)
	if property == 'Enabled' then
		UpdateIcon()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Animation" referent="RBX630C285FF2994633893107DF6C03C757">
					<Properties>
						<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861246</url></Content>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Hold</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Animation" referent="RBX0655FBF4E2C5447F8D63F63FF9E19387">
					<Properties>
						<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861252</url></Content>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Throw</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBXC11E35A94C384C74B6CF575BB32265D9">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">CandyBombServerScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{737142F0-12C7-486B-8399-DF934101A223}</string>
						<ProtectedString name="Source">-- Made by SolarCrane

local RS = game:GetService('ReplicatedStorage')
local PlayersService = game:GetService("Players")
local Debris = game:GetService('Debris')

local Utility = require(RS:WaitForChild('Utility'))
local Signal = require(RS:WaitForChild('Signal'))

local SHOOT_VELOCITY = 80
local DEBRIS_TIME = 6
local COOLDOWN = 4 -- Seconds until tool can be used again
local TIME_BEFORE_RELEASE = 0.2

local LastShot = 0
local Equipped = false
local MyPlayer = nil
local Character = nil
local Tool = script.Parent
local Handle = Tool:WaitForChild('Handle')

local BeepSound = Handle:WaitForChild('Beep')
local BoomSound = Handle:WaitForChild('Boom')

local ThrowAnimTrack = nil
local HoldAnimTrack = nil

local BOMB_MESHID = 'http://www.roblox.com/asset?id=179628795'
local BOMB_TXID = 'http://www.roblox.com/asset?id=179628830'

local BombPrefabScript = script:WaitForChild('CandyBombExplosionScript')

local RequestShootServer = Tool:WaitForChild('RequestShootServer')

-- Pure functional
local function MakeBaseBomb(myPlayer, bombMesh, bombTexture)
	local bomb = Utility.Create'Part'
	{
		Name = 'Bomb';
		TopSurface = 'Smooth';
		BottomSurface = 'Smooth';
		CanCollide = false;
		RotVelocity = Vector3.new(Utility.Random(-math.pi,math.pi),
		                          Utility.Random(-math.pi,math.pi),
		                          Utility.Random(-math.pi,math.pi)) * 2;
		Utility.Create'SpecialMesh'{
			MeshId = bombMesh;
			TextureId = bombTexture;
			Scale = Vector3.new(1,1,1);
		};
	}
	bomb.Shape = Enum.PartType.Ball
	bomb.FormFactor = 'Custom'
	bomb.Size = Vector3.new(1.5, 1.5, 1.5)
	Utility.Create'BodyForce'
	{
		Name = "FloatForce";
		force = Vector3.new(0, bomb:GetMass() * 196.2 * 0.25, 0);
		Parent = bomb;
	}

	-- Attach creator tags to the bomb early on
	local creatorTag = Instance.new('ObjectValue', bomb)
	creatorTag.Name = 'creator'
	creatorTag.Value = myPlayer

	return bomb
end

local function GetShootOrigin()
	return Handle.CFrame.p
end


local function OnShoot(player, desiredShootRay, localTime, desiredTarget, desiredTargetPosition)
	-- Someone else is trying to call shoot on my weapon; GET DENIED
	if player ~= MyPlayer then return end

	local now = tick()
	if now - LastShot &lt; COOLDOWN then
		return
	end
	local timeDiff = (tick() - localTime)
	local timeToWait = Utility.Clamp(0, TIME_BEFORE_RELEASE, TIME_BEFORE_RELEASE - timeDiff)
	wait(timeToWait) -- wait for before release, syncing up to our round-trip-time to make it looks smooth back on the local client.
	if Equipped and Handle and Utility.CanFire(MyPlayer) then
		-- TODO: Add handle velocity to the velocity?
		local adjustedShootVector = desiredShootRay.Direction
		local shootOrigin = GetShootOrigin()
		if shootOrigin then
			if desiredTarget and desiredTargetPosition then
				local deltaOffset = desiredTarget:GetModelCFrame().p - desiredTargetPosition
				adjustedShootVector = adjustedShootVector.unit * (desiredTargetPosition - shootOrigin).magnitude
				adjustedShootVector = adjustedShootVector + deltaOffset
				if adjustedShootVector.magnitude == 0 then
					adjustedShootVector = Vector3.new(0, 1, 0)
				end
			end
			local projectile = MakeBaseBomb(MyPlayer, BOMB_MESHID, BOMB_TXID)
			projectile.CFrame = CFrame.new(shootOrigin)
			projectile.Velocity = adjustedShootVector.unit * SHOOT_VELOCITY

			projectile.CanCollide = false
			-- this way the projectile doesn't hit our character; unfortunately it means it doesn't hit a lot of things.
			local touchConn = projectile.Touched:connect(function(other)
				if Character and other then
					if other.CanCollide == true and not other:IsDescendantOf(Character) then
						projectile.CanCollide = true
					end
				end
			end)
			delay(0.2, function() projectile.CanCollide = true touchConn:disconnect() end)

			Debris:AddItem(projectile, DEBRIS_TIME)
			projectile.Parent = workspace

			BeepSound:Clone().Parent = projectile
			BoomSound:Clone().Parent = projectile

			local bombScript = BombPrefabScript:Clone()
			bombScript.Parent = projectile
			bombScript.Disabled = false

			LastShot = now
			return projectile
		end
	end
end

local function OnEquipped()
	Equipped = true
	Character = Tool.Parent
	if Character then
		MyPlayer = PlayersService:GetPlayerFromCharacter(Character)
	end
end

local function OnUnequipped()
	Equipped = false
end

--------------------
--| Script Logic |--
--------------------

RequestShootServer.OnServerInvoke = OnShoot

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

print"ServeBombLoaded"
</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
					<Item class="Script" referent="RBXE989766986B84984B26E77A9DEB0E3C1">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null /></Content>
							<string name="Name">CandyBombExplosionScript</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{B33D6827-A497-4787-BD19-62EDBF3584BB}</string>
							<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local FORCE_GRANULARITY = 2
local RADIUS_FACTOR = 0.75

local BLAST_RADIUS = 13
local BLAST_PRESSURE = 1000000 * FORCE_GRANULARITY

-----------------
--| Variables |--
-----------------

local DebrisService = game:GetService('Debris')
local ServerScriptService = game:GetService('ServerScriptService')

local TimeBomb = script.Parent

local BombMesh = TimeBomb:WaitForChild('Mesh')

local BoomSound = TimeBomb:WaitForChild('Boom')
local BeepSound = TimeBomb:WaitForChild('Beep')

local CreatorTag = TimeBomb:WaitForChild('creator')


local MonsterContainer = workspace:WaitForChild("MonsterContainer")
local MonsterManager = require(ServerScriptService.MonsterManager)

local Connection = nil
local XGraceDistance = 2.5
local YGraceDistance = 2.5

local doBlastBack = false

-----------------
--| Functions |--
-----------------


-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
	if subject and subject ~= workspace then
		local humanoid = subject:FindFirstChild('Humanoid')
		if humanoid then
			return subject, humanoid
		else
			return FindCharacterAncestor(subject.Parent)
		end
	end
	return nil
end


local function cl0(n)
	return (n &gt; 0) and n or 0
end
local abs = math.abs
local function RealDistanceFrom(point, part)
	local p = part.CFrame:vectorToObjectSpace(point-part.Position)
	local hz = part.Size/2
	local sep = Vector3.new(cl0(abs(p.x)-hz.x), cl0(abs(p.y)-hz.y), cl0(abs(p.z)-hz.z))
	return sep.magnitude
end


local function TryDoDamage(humanoid, damage)
	local hitBindable = humanoid:FindFirstChild('Hit')
	local wasAlive = humanoid.Health &gt; 0
	if hitBindable then
		hitBindable:Invoke(damage, CreatorTag)
	else
		humanoid:TakeDamage(damage)
		MonsterManager:TagPlayerCollection(CreatorTag.Value, humanoid)
	end
end


-- Needless to say, this should only be called once
local Exploded = false
local function Explode()
	if Exploded then
		return
	end
	Exploded = true
	if Connection then
		Connection:disconnect()
	end
	local damagedMonsterSet = {}
	local function onExplosionHit(p, r)
		local isInCharacter = false
		if p.Size.magnitude/2 &lt; 20 then
			--world-&gt;ticklePrimitive(p, true);

			local doBreakjoints = false
			local hitCharacter, hitHumanoid = FindCharacterAncestor(p)
			if hitCharacter then
				-- flag as character
				isInCharacter = true

				-- don't breakjoints characters
				doBreakjoints = false

				-- work out what damage to do
				local hitPlayer = game.Players:GetPlayerFromCharacter(hitCharacter)
				local hitMonster = MonsterContainer and hitCharacter:IsDescendantOf(MonsterContainer) and hitCharacter
				local myPlayer = CreatorTag.Value
				if hitMonster and not damagedMonsterSet[hitMonster] then
					-- how much damage to do
					local damageFrac;
					if r &lt; BLAST_RADIUS/2 then
						damageFrac = 1
					elseif r &lt; BLAST_RADIUS then
						damageFrac = 1 - (r - BLAST_RADIUS/2)/(BLAST_RADIUS/2)
					else
						damageFrac = 0
					end

					-- flag as hit
					damagedMonsterSet[hitMonster] = true

					-- do damage. See how much damage to do
					TryDoDamage(hitHumanoid, 30 + 70*damageFrac)
					--print("Doing damage to:" , hitMonster , "of damage:" , 30 + 70*damageFrac)
				end
			end

			-- breakjoints stuff
			if doBreakjoints then
				-- Don't breakjoints stuff too far away to reduce lag
				if RealDistanceFrom(TimeBomb.Position, p) &gt; BLAST_RADIUS*RADIUS_FACTOR then
					return
				end
				p:BreakJoints()
			end
			if doBlastBack then
				--Vector3 delta = (p-&gt;getCoordinateFrame().translation - position);
				local delta = p.Position - TimeBomb.Position

				--Vector3 normal =
				--	(delta == Vector3::zero())
				--	? Vector3::unitY()
				--	: delta.direction();
				local normal = (delta == Vector3.new(0,0,0))
				               and Vector3.new(0,1,0)
				               or  delta.unit

				--float radius = p-&gt;getRadius();
				local radius = p.Size.magnitude / 2

				--float surfaceArea = radius * radius;
				local surfaceArea = radius * radius

				--Vector3 impulse = normal * blastPressure * surfaceArea * (1.0f / 4560.0f); // normalizing factor
				local impulse = normal * BLAST_PRESSURE * surfaceArea * (1.0 / 4560.0)

				-- How much force to apply (for characters, ramp it down towards the edge)
				local frac;
				if isInCharacter then
					frac = 1 - math.max(0, math.min(1, (r-2)/BLAST_RADIUS))
				else
					frac = 1
				end

				--p-&gt;getBody()-&gt;accumulateLinearImpulse(impulse, p-&gt;getCoordinateFrame().translation);
				local currentVelocity = p.Velocity
				local deltaVelocity = impulse / p:GetMass() -- m * del-v = F * del-t = Impulse
				local bodyV = Instance.new('BodyVelocity', p)
				bodyV.velocity = currentVelocity + deltaVelocity
				local forceNeeded = 196.2 * p:GetMass() -- F = ma
				bodyV.maxForce = Vector3.new(forceNeeded, forceNeeded, forceNeeded) * 10 * frac
				game.Debris:AddItem(bodyV, 0.2/FORCE_GRANULARITY)

				--p-&gt;getBody()-&gt;accumulateRotationalImpulse(impulse * 0.5 * radius); // a somewhat arbitrary, but nice torque
				local rotImpulse = impulse * 0.5 * radius
				local currentRotVelocity = p.RotVelocity
				local momentOfInertia = (2 * p:GetMass() * radius * radius / 5) -- moment of inertia = 2/5*m*r^2 (assuming roughly spherical)
				local deltaRotVelocity = rotImpulse / momentOfInertia
				local rot = Instance.new('BodyAngularVelocity', p)
				local torqueNeeded = 20 * momentOfInertia -- torque = r x F, want about alpha = 20 rad/s^2, alpha * P = torque
				rot.maxTorque = Vector3.new(torqueNeeded, torqueNeeded, torqueNeeded) * 10 * frac
				rot.angularvelocity = currentRotVelocity + deltaRotVelocity
				game.Debris:AddItem(rot, 0.2/FORCE_GRANULARITY)
			end
		end
	end

	local explosion = Instance.new('Explosion')
	explosion.BlastRadius = BLAST_RADIUS
	explosion.BlastPressure = 0
	explosion.Position = TimeBomb.Position
	explosion.Hit:connect(onExplosionHit)
	explosion.Parent = workspace

	BoomSound:Play()

	-- NOTE:
	-- If we just destroyed the bomb at this point, the boom sound would be destroyed too,
	-- so instead we will hide the bomb, keep it in the same spot, and schedule it for deletion

	TimeBomb.Transparency = 1
	TimeBomb.CanCollide = false
	TimeBomb.Anchored = true
	DebrisService:AddItem(TimeBomb, 3)
end

--------------------
--| Script Logic |--
--------------------

--Distance check to see if can collide should be true
--[[
spawn(function()
	while not TimeBomb.CanCollide and ParentTorso.Value do
		local TorsoPosition = ParentTorso.Value.CFrame.p
		local XZOffset = TorsoPosition-Vector3.new(TimeBomb.CFrame.p.x,TorsoPosition.y,TimeBomb.CFrame.p.z)
		if XZOffset.magnitude&gt;XGraceDistance or math.abs(TorsoPosition.y-TimeBomb.CFrame.p.y)&gt;YGraceDistance then
			TimeBomb.CanCollide=true
		end
		wait(1/30)
	end
end)
--]]

local Character = CreatorTag and CreatorTag.Value and CreatorTag.Value.Character

local touchConn = TimeBomb.Touched:connect(function(other)
	if Character and other and TimeBomb then
		if other.CanCollide == true and not other:IsDescendantOf(Character) then
			TimeBomb.CanCollide = true
		end
	end
end)
delay(0.2, function()
	if TimeBomb then TimeBomb.CanCollide = true end
	if touchConn then touchConn:disconnect() end
end)

Connection = TimeBomb.Touched:connect(function(other)
	local hitCharacter, hitHumanoid = FindCharacterAncestor(other)
	if hitCharacter and hitCharacter ~= CreatorTag.Value.Character then
		print("HitCharacter")
		local hitMonster = MonsterContainer and hitCharacter:IsDescendantOf(MonsterContainer)
		if hitMonster then
			print("HitMonster")
			Explode()
		end
	end
end)

-- Flash red and beep increasingly fast for about 3 seconds
local tickTime = 0.4
local red = true
repeat
	BombMesh.VertexColor = red and Vector3.new(1,0,0) or Vector3.new(1, 1, 1)
	BeepSound:Play()
	wait(tickTime)
	red = not red
	tickTime = tickTime * 0.9
until tickTime &lt; 0.1 or Exploded

Explode()
</ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
						</Properties>
					</Item>
				</Item>
				<Item class="RemoteFunction" referent="RBX6B642AB2675445B0ABC6BF075E18DBFE">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">RequestShootServer</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
			</Item>
		</Item>
		