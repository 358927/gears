<Item class="Model" referent="RBXA6C896EDC7AC478AAB05277E55DF9BB9">
			<Properties>
				<BinaryString name="AttributesSerialize" />
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">431044405</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags" />
				<OptionalCoordinateFrame name="WorldPivotData" />
			</Properties>
			<Item class="Tool" referent="RBX1931B141ED1A44DFB43118894A3AB1DC">
				<Properties>
					<BinaryString name="AttributesSerialize" />
					<bool name="CanBeDropped">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>-0.523324668</R00>
						<R01>-0.0702147558</R01>
						<R02>-0.849235654</R02>
						<R10>-0.243406817</R10>
						<R11>0.967394352</R11>
						<R12>0.0700105578</R12>
						<R20>0.816629887</R20>
						<R21>0.243348032</R21>
						<R22>-0.523352087</R22>
					</CoordinateFrame>
					<token name="LevelOfDetail">0</token>
					<bool name="ManualActivationOnly">false</bool>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">ReaperScythe</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<bool name="RequiresHandle">true</bool>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags" />
					<Content name="TextureId"><url>rbxassetid://511942532</url></Content>
					<string name="ToolTip" />
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-2.16904569</X>
							<Y>5.08487511</Y>
							<Z>25.1129627</Z>
							<R00>0.837265968</R00>
							<R01>-0.542357266</R01>
							<R02>0.0695297718</R02>
							<R10>0.484638005</R10>
							<R11>0.794947386</R11>
							<R12>0.364944935</R12>
							<R20>-0.253203005</R20>
							<R21>-0.271859199</R21>
							<R22>0.928429306</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBXE666430CEA6D4D16A14276351A8365DB">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize" />
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-2.16904569</X>
							<Y>5.08487511</Y>
							<Z>25.1129627</Z>
							<R00>0.837265968</R00>
							<R01>-0.542357266</R01>
							<R02>0.0695297718</R02>
							<R10>0.484638005</R10>
							<R11>0.794947386</R11>
							<R12>0.364944935</R12>
							<R20>-0.253203005</R20>
							<R21>-0.271859199</R21>
							<R22>0.928429306</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized" />
						<string name="Name">Handle</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>2</X>
							<Y>5.5</Y>
							<Z>0.349999994</Z>
						</Vector3>
					</Properties>
					<Item class="SpecialMesh" referent="RBXFF6720D22A3D4CC5A62D06C03699F1B2">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="MeshId"><url>rbxassetid://511942648</url></Content>
							<token name="MeshType">5</token>
							<string name="Name">Mesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>0.699999988</X>
								<Y>0.699999988</Y>
								<Z>0.699999988</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<Content name="TextureId"><url>rbxassetid://511942422</url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBX09DD28DFD41747E7A68A60D310BDFBC9">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="IsMutedForCapture">false</bool>
							<NumberRange name="LoopRegion">0 60000 </NumberRange>
							<bool name="Looped">false</bool>
							<string name="Name">Slash</string>
							<bool name="PlayOnRemove">false</bool>
							<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
							<bool name="PlaybackRegionsEnabled">false</bool>
							<float name="PlaybackSpeed">1</float>
							<bool name="Playing">false</bool>
							<float name="RollOffMaxDistance">10000</float>
							<float name="RollOffMinDistance">10</float>
							<token name="RollOffMode">0</token>
							<Ref name="SoundGroup">null</Ref>
							<Content name="SoundId"><url>rbxasset://sounds/swordslash.wav</url></Content>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<double name="TimePosition">0</double>
							<float name="Volume">1</float>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBXBCB5C4BF698749EA85BACDFD8DABADF8">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">MouseIcon</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{94FF88A9-D1A0-45DD-98E3-36F2682BD632}</string>
						<ProtectedString name="Source">--Made by Luckymaxer

Mouse_Icon = "rbxasset://textures/GunCursor.png"
Reloading_Icon = "rbxasset://textures/GunWaitCursor.png"

Tool = script.Parent

Mouse = nil

function UpdateIcon()
	if Mouse then
		Mouse.Icon = Tool.Enabled and Mouse_Icon or Reloading_Icon
	end
end

function OnEquipped(ToolMouse)
	Mouse = ToolMouse
	UpdateIcon()
end

function OnChanged(Property)
	if Property == "Enabled" then
		UpdateIcon()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Animation" referent="RBX173F563FB86048B0B8F22E5446217FB7">
					<Properties>
						<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=176223120</url></Content>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Equip</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Animation" referent="RBX602E8D66029144B3956BE50E3165F289">
					<Properties>
						<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=27763344</url></Content>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Slash</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBXB1B55276B8BD43818D909D78E1AD165E">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">Script</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{B77592EE-7C7F-4F89-96C6-567AF3B07D3D}</string>
						<ProtectedString name="Source">--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

local function Create_PrivImpl(objectType)
	if type(objectType) ~= 'string' then
		error("Argument of Create must be a string", 2)
	end
	--return the proxy function that gives us the nice Create'string'{data} syntax
	--The first function call is a function call using Lua's single-string-argument syntax
	--The second function call is using Lua's single-table-argument syntax
	--Both can be chained together for the nice effect.
	return function(dat)
		--default to nothing, to handle the no argument given case
		dat = dat or {}

		--make the object to mutate
		local obj = Instance.new(objectType)
		local parent = nil

		--stored constructor function to be called after other initialization
		local ctor = nil

		for k, v in pairs(dat) do
			--add property
			if type(k) == 'string' then
				if k == 'Parent' then
					-- Parent should always be set last, setting the Parent of a new object
					-- immediately makes performance worse for all subsequent property updates.
					parent = v
				else
					obj[k] = v
				end


			--add child
			elseif type(k) == 'number' then
				if type(v) ~= 'userdata' then
					error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
				end
				v.Parent = obj


			--event connect
			elseif type(k) == 'table' and k.__eventname then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
							got: "..tostring(v), 2)
				end
				obj[k.__eventname]:connect(v)


			--define constructor function
			elseif k == t.Create then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
							got: "..tostring(v), 2)
				elseif ctor then
					--ctor already exists, only one allowed
					error("Bad entry in Create body: Only one constructor function is allowed", 2)
				end
				ctor = v


			else
				error("Bad entry ("..tostring(k).." =&gt; "..tostring(v)..") in Create body", 2)
			end
		end

		--apply constructor function if it exists
		if ctor then
			ctor(obj)
		end

		if parent then
			obj.Parent = parent
		end

		--return the completed object
		return obj
	end
end

--now, create the functor:
Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
--function can recognize as special.
Create.E = function(eventName)
	return {__eventname = eventName}
end


Handle.Transparency = 0
Tool.Enabled = true

LastAttack = 0
Slashing = false
Debounce = false
ToolEquipped = false

BasePart = Create("Part"){
	Shape = Enum.PartType.Block,
	Material = Enum.Material.Plastic,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	FormFactor = Enum.FormFactor.Custom,
	Size = Vector3.new(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
	Anchored = false,
}

Sounds = {
	Slash = Handle:WaitForChild("Slash")
}

Animations = {
	Slash = {Animation = Tool:WaitForChild("Slash"), Weight = nil, FadeTime = nil, Speed = 1},
	Equip = {Animation = Tool:WaitForChild("Equip"), Weight = nil, FadeTime = nil, Speed = 1},
}

SkeletonRemains = {
	["Head"] = {MeshId = "4770583", TextureId = "36869975", Scale = Vector3.new(3, 3, 3)},
	["Torso"] = {MeshId = "36780113", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Left Arm"] = {MeshId = "36780032", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Right Arm"] = {MeshId = "36780156", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Left Leg"] = {MeshId = "36780079", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
	["Right Leg"] = {MeshId = "36780195", TextureId = "36780292", Scale = Vector3.new(1, 1, 1)},
}

BaseUrl = "http://www.roblox.com/asset/?id="

NPCScripts = script:WaitForChild("NPCScripts")

Remotes = Tool:WaitForChild("Remotes")
ServerControl = (Remotes:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Remotes

ClientControl = (Remotes:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Remotes

function MakeNPCMinion(Table)
	local HumanoidProperties = (Table.HumanoidProperties or {})
	local Values = (Table.Values or {})
	local Limbs = {
		["Head"] = {Properties = {BrickColor = BrickColor.new("Bright yellow"), Size = Vector3.new(2, 1, 1),}},
		["HumanoidRootPart"] = {Properties = {BrickColor = BrickColor.new("Bright blue"), Transparency = 1, Size = Vector3.new(2, 2, 1),},},
		["Torso"] = {Properties = {BrickColor = BrickColor.new("Bright blue"), Size = Vector3.new(2, 2, 1),},},
		["Left Arm"] = {Properties = {BrickColor = BrickColor.new("Bright yellow"), Size = Vector3.new(1, 2, 1),},},
		["Right Arm"] = {Properties = {BrickColor = BrickColor.new("Bright yellow"), Size = Vector3.new(1, 2, 1),},},
		["Left Leg"] = {Properties = {BrickColor = BrickColor.new("Br. yellowish green"), Size = Vector3.new(1, 2, 1),},},
		["Right Leg"] = {Properties = {BrickColor = BrickColor.new("Br. yellowish green"), Size = Vector3.new(1, 2, 1),},},
	}
	local Joints = {
		["RootJoint"] = {Parent = "HumanoidRootPart", Part0 = "HumanoidRootPart", Part1 = "Torso", Properties = {C0 = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), C1 = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Neck"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Head", Properties = {C0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), C1 = CFrame.new(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Left Shoulder"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Left Arm", Properties = {C0 = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), C1 = CFrame.new(0.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Right Shoulder"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Right Arm", Properties = {C0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), C1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Left Hip"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Left Leg", Properties = {C0 = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), C1 = CFrame.new(-0.5, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
		["Right Hip"] = {Parent = "Torso", Part0 = "Torso", Part1 = "Right Leg", Properties = {C0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), C1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), MaxVelocity = 0.1, DesiredAngle = 0, CurrentAngle = 0}},
	}
	local Misc = {
		{Class = "Decal", Parent = "Head", Properties = {Name = "face", Texture = (BaseUrl .. "144080495"), Shiny = 20, Specular = 0, Transparency = 0, Face = Enum.NormalId.Front}},
		{Class = "Decal", Parent = "Torso", Properties = {Name = "roblox", Texture = "", Shiny = 20, Specular = 0, Transparency = 0, Face = Enum.NormalId.Front}},
		{Class = "SpecialMesh", Parent = "Head", Properties = {MeshType = Enum.MeshType.Head, Scale = Vector3.new(1.25, 1.25, 1.25)}},
	}
	local NPC = Create("Model"){
		Name = "NPC",
	}
	local Humanoid = Create("Humanoid"){
		Name = "Humanoid",
	}
	for i, v in pairs(HumanoidProperties) do
		pcall(function()
			Humanoid[i] = v
		end)
	end
	Humanoid.Name = "Humanoid"
	Humanoid.Parent = NPC
	Humanoid.Health = Humanoid.MaxHealth
	for i, v in pairs(Values) do
		local Value = Create(v.Class){
			Name = v.Name,
			Value = v.Value,
			Parent = NPC,
		}
	end
	for i, v in pairs(Limbs) do
		local Limb = BasePart:Clone()
		for ii, vv in pairs(v.Properties) do
			pcall(function()
				Limb[ii] = vv
			end)
		end
		Limb.Name = i
		Limb.Parent = NPC
	end
	for i, v in pairs(Joints) do
		local Joint = Create("Motor"){
		}
		for ii, vv in pairs(v.Properties) do
			pcall(function()
				Joint[ii] = vv
			end)
		end
		Joint.Name = i
		Joint.Part0 = NPC:FindFirstChild(v.Part0)
		Joint.Part1 = NPC:FindFirstChild(v.Part1)
		Joint.Parent = NPC:FindFirstChild(v.Parent)
	end
	for i, v in pairs(Misc) do
		local Decal = Create(v.Class){
		}
		for ii, vv in pairs(v.Properties) do
			pcall(function()
				Decal[ii] = vv
			end)
		end
		Decal.Parent = NPC:FindFirstChild(v.Parent)
	end
	local FakeHat = Create("Hat"){
		Name = "NoHat",
		Parent = NPC,
	}
	for i, v in pairs(NPCScripts:GetChildren()) do
		if v:IsA("Script") then
			local ScriptCopy = v:Clone()
			ScriptCopy.Disabled = false
			ScriptCopy.Parent = NPC
		end
	end
	return NPC
end

function DeathEffect(character, Alive)
	local NoEffect = character:FindFirstChild("NoEffect")
	if NoEffect then
		return
	end
	local function Materialize(Object)
		if Object:IsA("BasePart") then
			Object.BrickColor = BrickColor.new("Institutional white")
			local Remains = SkeletonRemains[Object.Name]
			if Remains then
				for ii, vv in pairs(Object:GetChildren()) do
					if vv:IsA("DataModelMesh") or vv:IsA("Decal") or vv:IsA("Texture") then
						vv:Destroy()
					end
				end
				local NewMesh = Create("SpecialMesh"){
					Name = "Mesh",
					MeshType = Enum.MeshType.FileMesh,
					MeshId = (BaseUrl .. Remains.MeshId),
					TextureId = (BaseUrl .. Remains.TextureId),
					Scale = Remains.Scale,
					VertexColor = Vector3.new(1, 1, 1),
					Offset = Vector3.new(0, 0, 0),
					Parent = Object,
				}
			end
			for ii, vv in pairs(Object:GetChildren()) do
				if vv:IsA("DataModelMesh") then
					vv.VertexColor = Vector3.new(0, 0, 0)
				end
			end
		elseif Object:IsA("CharacterMesh") or Object:IsA("Clothing") then
			Object:Destroy()
		elseif Object:IsA("DataModelMesh") then
			Object.VertexColor = Vector3.new(0, 0, 0)
		end
	end
	local function Effect(Parent)
		for i, v in pairs(Parent:GetChildren()) do
			Materialize(v)
			Effect(v)
		end
	end
	local humanoid = character:FindFirstChild("Humanoid")
	local OwnerCreator = character:FindFirstChild("Creator")
	if humanoid and humanoid.Health &lt;= 0 and (not OwnerCreator or (OwnerCreator and OwnerCreator.Value ~= Player)) then
		local DeadTorso = character:FindFirstChild("Torso")
		local Killer = humanoid:FindFirstChild("creator")
		if Killer and Killer.Value == Player then
			local NoTransform = Killer:FindFirstChild("NoTransform")
			if not NoTransform then
				for i, v in pairs(character:GetChildren()) do
					if not v:IsA("Humanoid") then
						v:Destroy()
					end
				end
				local NPCValues = {
					{Name = "Damage", Class = "NumberValue", Value = 15},
					{Name = "HitDelay", Class = "NumberValue", Value = 0.1},
					{Name = "Creator", Class = "ObjectValue", Value = Player},
				}
				local NPC = MakeNPCMinion({HumanoidProperties = {MaxHealth = 250, WalkSpeed = 24}, Values = NPCValues})
				NPC.Name = "Skeleton"
				NPC.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
				for i, v in pairs(NPC:GetChildren()) do
					if v:IsA("BaseScript") then
						v.Disabled = true
					end
				end
				local ForceField = Create("ForceField"){
				}
				Debris:AddItem(ForceField, 0.75)
				ForceField.Parent = NPC
				DeathEffect(NPC, true)
				local NoEffect = Create("BoolValue"){
					Name = "NoEffect",
					Value = true,
					Parent = NPC
				}
				Debris:AddItem(NPC, 20)
				NPC.Parent = game:GetService("Workspace")
				local torso = NPC:FindFirstChild("Torso")
				if torso then
					torso.CFrame = DeadTorso.CFrame
				end
				for i, v in pairs(NPC:GetChildren()) do
					if v:IsA("BaseScript") then
						v.Disabled = false
					end
				end
			end
		end
	end
	Materialize(character)
	Effect(character)
end

function InvokeClient(Mode, Value)
	local ReturnValue = nil
	pcall(function()
		ReturnValue = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ReturnValue
end

function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function Blow(Hit)
	if not Hit or not Hit.Parent or not ToolEquipped or not CheckIfAlive() or Debounce then
		return
	end
	local character = Hit.Parent
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid or humanoid.Health == 0 then
		return
	end
	local player = Players:GetPlayerFromCharacter(character)
	if player and (player == Player or IsTeamMate(Player, player)) then
		return
	end
	Debounce = true
	UntagHumanoid(humanoid)
	TagHumanoid(humanoid, Player)
	humanoid:TakeDamage(22)
	if humanoid.Health &lt;= 0 then
		DeathEffect(character, true)
	end
	wait(0.1)
	Debounce = false
end

function Activated()
	if not ToolEquipped or not CheckIfAlive() then
		return
	end

	Tool.Enabled = false

	Tick = RunService.Stepped:wait()
	if (Tick - LastAttack &lt; 0.2) then
		wait(1)
	else
		if not Slashing then
			Slashing = true
			LastAttack = Tick
			Spawn(function()
				InvokeClient("PlayAnimation", Animations.Slash)
			end)
			Sounds.Slash:Play()
			wait(1)
			Slashing = false
		end
	end

	Tool.Enabled = true

end

function CheckIfAlive()
	return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health &gt; 0 and Torso and Torso.Parent) and true) or false)
end

function Equipped()
	ToolEquipped = true
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("HumanoidRootPart")
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		InvokeClient("PlayAnimation", Animations.Equip)
	end)
end

function Unequipped()
	ToolEquipped = false
	if CheckIfAlive() then
		Humanoid.WalkSpeed = 16
	end
end

Handle.Touched:connect(Blow)

Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
					<Item class="Folder" referent="RBX75D4E49652BB4DC89B191CC47A1A6577">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">NPCScripts</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
						</Properties>
						<Item class="Script" referent="RBXF1D7C51DAA034E41A3B1C7FC013E05D9">
							<Properties>
								<BinaryString name="AttributesSerialize" />
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null /></Content>
								<string name="Name">AIScript</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{068CAF2E-4F61-44D5-BFB6-5F33030970A6}</string>
								<ProtectedString name="Source">--Made by Luckymaxer

Figure = script.Parent
Humanoid = Figure:WaitForChild("Humanoid")
Torso = Figure:WaitForChild("Torso")

Players = game:GetService("Players")

Functions = require(script:WaitForChild("Functions"))

Creator = Figure:WaitForChild("Creator")
HitDelay = Figure:WaitForChild("HitDelay")
Damage = Figure:WaitForChild("Damage")

Rate = (1 / 60)

SpawnOrigin = Torso.Position

TouchDebounce = false

function CheckIfAlive()
	return (((Figure and Figure.Parent and Humanoid and Humanoid.Parent and Humanoid.Health &gt; 0 and Torso and Torso.Parent) and true) or false)
end

function GetCreatorPlayer()
	return (((Creator.Value and Creator.Value.Parent and Creator.Value:IsA("Player")) and Creator.Value) or nil)
end

function GetNearbyObjects(Region)
	local CreatorPlayer = GetCreatorPlayer()
	local IgnoreList = {Figure, ((CreatorPlayer and CreatorPlayer.Character) or nil)}
	for i, v in pairs(Players:GetChildren()) do
		if v:IsA("Player") and v ~= CreatorPlayer and v.Character and v.Character.Parent and (CreatorPlayer and Functions.IsTeamMate(CreatorPlayer, v)) then
			table.insert(IgnoreList, v.Character)
		end
	end
	return Functions.GetParts(Region, 500, IgnoreList)
end

function GetNearbyPlayers(Radius)
	local NearbyObjects = GetNearbyObjects(Radius)
	local Humanoids = {}
	for i, v in pairs(NearbyObjects) do
		local character = v.Parent
		if character then
			local creator = character:FindFirstChild("Creator")
			local humanoid = character:FindFirstChild("Humanoid")
			if (((creator and creator.Value ~= Creator.Value) or not creator) and (humanoid and not Functions.CheckTableForInstance(Humanoids, humanoid))) then
				table.insert(Humanoids, humanoid)
			end
		end
	end
	return Humanoids
end

function SecureJump()
	if not Humanoid or Humanoid.Jump or not Torso then
		return
	end
	local TargetPoint = Torso.Velocity.Unit
	local Blockage, BlockagePos = Functions.CastRay((Torso.CFrame + CFrame.new(Torso.Position, Vector3.new(TargetPoint.X, Torso.Position.Y, TargetPoint.Z)).lookVector * (Torso.Size.Z / 2)).p, Torso.CFrame.lookVector, (Torso.Size.Z * 2.5), {Figure, (((Creator and Creator.Value and Creator.Value:IsA("Player") and Creator.Value.Character) and Creator.Value.Character) or nil)}, false)
	local Jumpable = false
	if Blockage then
		Jumpable = true
		if Blockage:IsA("Terrain") then
			local CellPos = Blockage:WorldToCellPreferSolid((BlockagePos - Vector3.new(0, 2, 0)))
			local CellMaterial, CellShape, CellOrientation = Blockage:GetCell(CellPos.X, CellPos.Y, CellPos.Z)
			if CellMaterial == Enum.CellMaterial.Water then
				Jumpable = false
			end
		elseif Blockage.Parent:FindFirstChild("Humanoid") then
			Jumpable = false
		end
	end
	if Jumpable then
		Humanoid.Jump = true
	end
end

for i, v in pairs(Figure:GetChildren()) do
	if v:IsA("BasePart") then
		local TouchedConnection
		TouchedConnection = v.Touched:connect(function(Hit)
			if not Hit or not Hit.Parent or TouchDebounce then
				return
			end
			local Connected = false
			local ConnectedParts = v:GetConnectedParts()
			if #ConnectedParts &lt;= 1 then
				return
			end
			for i, v in pairs(ConnectedParts) do
				if v == Torso then
					Connected = true
				end
			end
			if not Connected then
				return
			end
			local character = Hit.Parent
			if character:IsA("Hat") then
				character = character.Parent
			end
			local player = Players:GetPlayerFromCharacter(character)
			local CreatorValue = Figure.Creator.Value
			if not CreatorValue then
				return
			end
			local CreatorPlayer = ((CreatorValue:IsA("Player") and CreatorValue) or Players:GetPlayerFromCharacter(CreatorValue))
			if player then
				if player == CreatorPlayer then
					return
				end
				if player and CreatorPlayer and Functions.IsTeamMate(CreatorPlayer, player) then
					return
				end
			end
			local creator = character:FindFirstChild("Creator")
			if creator and creator:IsA("ObjectValue") and creator.Value == CreatorValue then
				return
			end
			local humanoid = character:FindFirstChild("Humanoid")
			if not humanoid or not humanoid:IsA("Humanoid") or humanoid.Health == 0 then
				return
			end
			TouchDebounce = true
			Functions.UntagHumanoid(humanoid)
			Functions.TagHumanoid(humanoid, CreatorPlayer)
			humanoid:TakeDamage(Damage.Value)
			wait(HitDelay.Value)
			TouchDebounce = false
		end)
	end
end

Walk = {Tick = 0, Delay = 0}

while CheckIfAlive() do
	local Now = tick()
	local WalkToPosition = nil
	if (Now - Walk.Tick) &gt; Walk.Delay then
		local MaxDistance = 45
		local NearbyPlayers = GetNearbyPlayers(Region3.new((Torso.Position - Vector3.new(MaxDistance, (Torso.Size.Y * 2), MaxDistance)), (Torso.Position + Vector3.new(MaxDistance, MaxDistance, MaxDistance))))
		if #NearbyPlayers &gt; 0 then
			local ClosestPlayer = {Distance = MaxDistance, Character = nil}
			for i, v in pairs(NearbyPlayers) do
				local humanoid = v
				local character = v.Parent
				if character and character.Parent then
					local humanoid = character:FindFirstChild("Humanoid")
					local torso = character:FindFirstChild("Torso")
					if humanoid and humanoid.Health &gt; 0 and torso then
						local DistanceApart = (Torso.Position - torso.Position).Magnitude
						if DistanceApart &lt; ClosestPlayer.Distance then
							ClosestPlayer.Distance = DistanceApart
							ClosestPlayer.Character = character
						end
					end
				end
			end
			local ClosestCharacter = ClosestPlayer.Character
			if ClosestCharacter and ClosestCharacter.Parent then
				local torso = ClosestCharacter:FindFirstChild("Torso")
				if torso then
					WalkToPosition = torso.Position
				end
			end
		else
			local WalkRadius = 10
			WalkToPosition = (Torso.Position + Vector3.new(math.random(-WalkRadius, WalkRadius), 0, math.random(-WalkRadius, WalkRadius)))
			Walk.Delay = (math.random(500, 3500) * 0.001)
			Walk.Tick = Now
		end
	end
	if WalkToPosition and (SpawnOrigin - WalkToPosition).Magnitude &gt; 75 then
		WalkToPosition = Torso.Position
	end
	if WalkToPosition then
		SecureJump()
		Humanoid:MoveTo(WalkToPosition)
	end
	wait(Rate)
end</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags" />
							</Properties>
							<Item class="ModuleScript" referent="RBXAECD692A51F74C649C206D0BBD14649B">
								<Properties>
									<BinaryString name="AttributesSerialize" />
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null /></Content>
									<string name="Name">Functions</string>
									<string name="ScriptGuid">{A420D1E1-7FC8-4CC9-A9E8-D92755B3BE6F}</string>
									<ProtectedString name="Source">--Made by Luckymaxer

Debris = game:GetService("Debris")

RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create

Functions = {

	CheckTableForString = (function(Table, String)
		for i, v in pairs(Table) do
			if string.lower(v) == string.lower(String) then
				return true
			end
		end
		return false
	end),

	CheckIntangible = (function(Hit)
		local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Laser", "Ray", "Bullet", "ParticlePart"}
		if Hit and Hit.Parent then
			if (Hit.Transparency &gt;= 1 and not Hit.CanCollide) or Functions.CheckTableForString(ProjectileNames, Hit.Name) then
				return true
			end
			local ObjectParent = Hit.Parent
			local Character = ObjectParent.Parent
			local Humanoid = Character:FindFirstChild("Humanoid")
			if Humanoid and Humanoid.Health &gt; 0 and ObjectParent:IsA("Hat") then
				return true
			end
		end
		return false
	end),

	CastRay = (function(StartPos, Vec, Length, Ignore, DelayIfHit)
		local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
		if RayHit and Functions.CheckIntangible(RayHit) then
			if DelayIfHit then
				wait()
			end
			RayHit, RayPos, RayNormal = Functions.CastRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
		end
		return RayHit, RayPos, RayNormal
	end),

	TagHumanoid = (function(humanoid, player)
		local Creator_Tag = Create("ObjectValue"){
			Name = "creator",
			Value = player,
		}
		local NoTransform = Create("BoolValue"){
			Name = "NoTransform",
			Value = true,
			Parent = Creator_Tag,
		}
		Debris:AddItem(Creator_Tag, 2)
		Creator_Tag.Parent = humanoid
	end),

	UntagHumanoid = (function(humanoid)
		for i, v in pairs(humanoid:GetChildren()) do
			if v:IsA("ObjectValue") and v.Name == "creator" then
				v:Destroy()
			end
		end
	end),

	IsTeamMate = (function(Player1, Player2)
		return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
	end),

	Clamp = (function(Number, Min, Max)
		return math.max(math.min(Max, Number), Min)
	end),

	GetPercentage = (function(Start, End, Number)
		return (((Number - Start) / (End - Start)) * 100)
	end),

	Round = (function(Number, RoundDecimal)
		local WholeNumber, Decimal = math.modf(Number)
		return ((Decimal &gt;= RoundDecimal and math.ceil(Number)) or (Decimal &lt; RoundDecimal and math.floor(Number)))
	end),

	CheckTableForInstance = (function(Table, Instance)
		for i, v in pairs(Table) do
			if v == Instance then
				return true
			end
		end
		return false
	end),

	GetAllConnectedParts = (function(Object)
		local Parts = {}
		local function GetConnectedParts(Object)
			for i, v in pairs(Object:GetConnectedParts()) do
				local Ignore = false
				for ii, vv in pairs(Parts) do
					if v == vv then
						Ignore = true
					end
				end
				if not Ignore then
					table.insert(Parts, v)
					GetConnectedParts(v)
				end
			end
		end
		GetConnectedParts(Object)
		return Parts
	end),

	GetTotalParts = (function(MaxParts, PossibleParts, Parts)
		if MaxParts &lt; PossibleParts then
			return MaxParts
		elseif Parts &gt;= MaxParts then
			return 0
		elseif MaxParts &gt;= PossibleParts then
			local PartCount = (MaxParts - PossibleParts)
			if Parts &lt;= MaxParts then
				PartCount = (MaxParts - Parts)
				if PartCount &gt; PossibleParts then
					return PossibleParts
				else
					return PartCount
				end
			elseif PartCount &gt;= PossibleParts then
				return PossibleParts
			else
				return PartCount
			end
		end
	end),

	GetParts = (function(Region, MaxParts, Ignore)
		local Parts = {}
		local RerunFailed = false
		while #Parts &lt; MaxParts and not RerunFailed do
			local Region = Region
			local PossibleParts = Functions.GetTotalParts(MaxParts, 100, #Parts)
			local PartsNearby = game:GetService("Workspace"):FindPartsInRegion3WithIgnoreList(Region, Ignore, PossibleParts)
			if #PartsNearby == 0 then
				RerunFailed = true
			else
				for i, v in pairs(PartsNearby) do
					table.insert(Parts, v)
					table.insert(Ignore, v)
				end
			end
		end
		return Parts
	end),

}

return Functions</ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags" />
								</Properties>
							</Item>
						</Item>
						<Item class="Script" referent="RBXC5B9763D06FF4AF1A5BCD6CA059C4899">
							<Properties>
								<BinaryString name="AttributesSerialize" />
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null /></Content>
								<string name="Name">RegenerateHealth</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{20CEFF70-0A40-40FA-AAAC-781CFE76FE31}</string>
								<ProtectedString name="Source">--Made by Luckymaxer

Figure = script.Parent
Humanoid = Figure:WaitForChild("Humanoid")

Regenerating = false

function RegenerateHealth()
	if Regenerating then
		return
	end
	Regenerating = true
	while Humanoid.Health &lt; Humanoid.MaxHealth do
		local Second = wait(1)
		local Health = Humanoid.Health
		if Health &gt; 0 and Health &lt; Humanoid.MaxHealth then
			local NewHealthDelta = (0.01 * Second * Humanoid.MaxHealth)
			Health = (Health + NewHealthDelta)
			Humanoid.Health = math.min(Health, Humanoid.MaxHealth)
		end
	end
	if Humanoid.Health &gt; Humanoid.MaxHealth then
		Humanoid.Health = Humanoid.MaxHealth
	end
	Regenerating = false
end

Humanoid.HealthChanged:connect(RegenerateHealth)</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags" />
							</Properties>
						</Item>
						<Item class="Script" referent="RBX3684110989C7442EA9563FEFD0A787F8">
							<Properties>
								<BinaryString name="AttributesSerialize" />
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null /></Content>
								<string name="Name">Animate</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{279DFC66-58D8-4FA3-BB28-6248768510F1}</string>
								<ProtectedString name="Source">--Made by Luckymaxer

Figure = script.Parent

RunService = game:GetService("RunService")
Debris = game:GetService("Debris")

Creator = Figure:FindFirstChild("Creator")

Humanoid = Figure:WaitForChild("Humanoid")
Head = Figure:WaitForChild("Head")
Torso = Figure:WaitForChild("Torso")

Neck = Torso:WaitForChild("Neck")
LeftShoulder = Torso:WaitForChild("Left Shoulder")
RightShoulder = Torso:WaitForChild("Right Shoulder")
LeftHip = Torso:WaitForChild("Left Hip")
RightHip = Torso:WaitForChild("Right Hip")

for i, v in pairs({Neck, LeftShoulder, RightShoulder, LeftHip, RightHip}) do
	if v and v.Parent then
		v.DesiredAngle = 0
		v.CurrentAngle = 0
	end
end

Pose = "None"
LastPose = Pose
PoseTime = tick()

ToolAnimTime = 0

function SetPose(pose)
	LastPose = Pose
	Pose = pose
	PoseTime = tick()
end

function OnRunning(Speed)
	if Speed &gt; 0 then
		SetPose("Running")
	else
		SetPose("Standing")
	end
end

function OnDied()
	SetPose("Dead")
	Debris:AddItem(Figure, 3)
end

function OnJumping()
	SetPose("Jumping")
end

function OnClimbing()
	SetPose("Climbing")
end

function OnGettingUp()
	SetPose("GettingUp")
end

function OnFreeFall()
	SetPose("FreeFall")
end

function OnFallingDown()
	SetPose("FallingDown")
end

function OnSeated()
	SetPose("Seated")
end

function OnPlatformStanding()
	SetPose("PlatformStanding")
end

function OnSwimming(Speed)
	return OnRunning(Speed)
end

function MoveJump()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder.DesiredAngle = math.pi
	LeftShoulder.DesiredAngle = -math.pi
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function MoveFreeFall()
	RightShoulder.MaxVelocity = 0.25
	LeftShoulder.MaxVelocity = 0.25
	RightShoulder.DesiredAngle = math.pi
	LeftShoulder.DesiredAngle = -math.pi
	RightHip.DesiredAngle = 0
	LeftHip.DesiredAngle = 0
end

function MoveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder.DesiredAngle = (math.pi / 2)
	LeftShoulder.DesiredAngle = -(math.pi / 2)
	RightHip.DesiredAngle = 1
	LeftHip.DesiredAngle = -1
end

function GetTool()
	for i, v in pairs(Figure:GetChildren()) do
		if v:IsA("Tool") then
			return v
		end
	end
end

function GetToolAnim(Tool)
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("StringValue") and v.Name == "ToolAnim" then
			return v
		end
	end
	return nil
end

function AnimateTool()

	if (ToolAnim == "None") then
		return
	end

	if (ToolAnim == "Slash") then
		RightShoulder.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = 0
		return
	end

	if (ToolAnim == "Lunge") then
		RightShoulder.MaxVelocity = 0.5
		LeftShoulder.MaxVelocity = 0.5
		RightHip.MaxVelocity = 0.5
		LeftHip.MaxVelocity = 0.5
		RightShoulder.DesiredAngle = (math.pi / 2)
		LeftShoulder.DesiredAngle = 0
		RightHip.DesiredAngle = (math.pi / 2)
		LeftHip.DesiredAngle = 1
		return
	end

end

function Move(Time)
	local LimbAmplitude
	local LimbFrequency
	local NeckAmplitude
	local NeckFrequency
	local NeckDesiredAngle

	if (Pose == "Jumping") then
		MoveJump()
		return
	elseif (Pose == "FreeFall") then
		MoveFreeFall()
		return
	elseif (Pose == "Seated") then
		MoveSit()
		return
	end

	local ClimbFudge = 0

	if (Pose == "Running") then
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		LimbAmplitude = 1
		LimbFrequency = 9
		NeckAmplitude = 0
		NeckFrequency = 0
		NeckDesiredAngle = 0
		--[[if Creator and Creator.Value and Creator.Value:IsA("Player") and Creator.Value.Character then
			local CreatorCharacter = Creator.Value.Character
			local CreatorHead = CreatorCharacter:FindFirstChild("Head")
			if CreatorHead then
				local TargetPosition = CreatorHead.Position
				local Direction = Torso.CFrame.lookVector
				local HeadPosition = Head.Position
				NeckDesiredAngle = ((((HeadPosition - TargetPosition).Unit):Cross(Direction)).Y / 4)
			end
		end]]
	elseif (Pose == "Climbing") then
		RightShoulder.MaxVelocity = 0.5
		LeftShoulder.MaxVelocity = 0.5
		LimbAmplitude = 1
		LimbFrequency = 9
		NeckAmplitude = 0
		NeckFrequency = 0
		NeckDesiredAngle = 0
		ClimbFudge = math.pi
	else
		LimbAmplitude = 0.1
		LimbFrequency = 1
		NeckAmplitude = 0.25
		NeckFrequency = 1.25
	end

	NeckDesiredAngle = ((not NeckDesiredAngle and (NeckAmplitude * math.sin(Time * NeckFrequency))) or NeckDesiredAngle)
	LimbDesiredAngle = (LimbAmplitude * math.sin(Time * LimbFrequency))

	--Neck.DesiredAngle = NeckDesiredAngle
	RightShoulder.DesiredAngle = (LimbDesiredAngle + ClimbFudge)
	LeftShoulder.DesiredAngle = (LimbDesiredAngle - ClimbFudge)
	RightHip.DesiredAngle = -LimbDesiredAngle
	LeftHip.DesiredAngle = -LimbDesiredAngle

	local Tool = GetTool()

	if Tool then

		AnimStringValueObject = GetToolAnim(Tool)

		if AnimStringValueObject then
			ToolAnim = AnimStringValueObject.Value
			if AnimStringValueObject and AnimStringValueObject.Parent then
				AnimStringValueObject:Destroy()
			end
			ToolAnimTime = (Time + 0.3)
		end

		if Time &gt; ToolAnimTime then
			ToolAnimTime = 0
			ToolAnim = "None"
		end

		AnimateTool()

	else
		ToolAnim = "None"
		ToolAnimTime = 0
	end

end

Humanoid.Died:connect(OnDied)
Humanoid.Running:connect(OnRunning)
Humanoid.Jumping:connect(OnJumping)
Humanoid.Climbing:connect(OnClimbing)
Humanoid.GettingUp:connect(OnGettingUp)
Humanoid.FreeFalling:connect(OnFreeFall)
Humanoid.FallingDown:connect(OnFallingDown)
Humanoid.Seated:connect(OnSeated)
Humanoid.PlatformStanding:connect(OnPlatformStanding)
Humanoid.Swimming:connect(OnSwimming)

Humanoid:ChangeState(Enum.HumanoidStateType.None)

RunService.Stepped:connect(function()
	local _, Time = wait(0.1)
	Move(Time)
end)</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags" />
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX3E67A02BF16A4FEA80B9C4C3EBFBF87E">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">LocalScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{B49A9DA2-8A2B-4081-8849-F221059A9156}</string>
						<ProtectedString name="Source">--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
RunService = game:GetService("RunService")

Animations = {}

Remotes = Tool:WaitForChild("Remotes")
ServerControl = Remotes:WaitForChild("ServerControl")
ClientControl = Remotes:WaitForChild("ClientControl")

Rate = (1 / 60)

ToolEquipped = false

function SetAnimation(mode, value)
	if mode == "PlayAnimation" and value and ToolEquipped and Humanoid then
		for i, v in pairs(Animations) do
			if v.Animation == value.Animation then
				v.AnimationTrack:Stop()
				table.remove(Animations, i)
			end
		end
		local AnimationTrack = Humanoid:LoadAnimation(value.Animation)
		table.insert(Animations, {Animation = value.Animation, AnimationTrack = AnimationTrack})
		AnimationTrack:Play(value.FadeTime, value.Weight, value.Speed)
	elseif mode == "StopAnimation" and value then
		for i, v in pairs(Animations) do
			if v.Animation == value.Animation then
				v.AnimationTrack:Stop(value.FadeTime)
				table.remove(Animations, i)
			end
		end
	end
end

function KeyPressed(Key, Down)
	InvokeServer("KeyPressed", {Key = Key, Down = Down})
end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health &gt; 0 and Player and Player.Parent) and true) or false)
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	ToolEquipped = true
	if not CheckIfAlive() then
		return
	end
	PlayerMouse = Mouse
	PlayerMouse.KeyDown:connect(function(Key)
		KeyPressed(Key, true)
	end)
	PlayerMouse.KeyUp:connect(function(Key)
		KeyPressed(Key, false)
	end)
end

function Unequipped()
	for i, v in pairs(Animations) do
		if v and v.AnimationTrack then
			v.AnimationTrack:Stop()
		end
	end
	Animations = {}
	ToolEquipped = false
end

function InvokeServer(mode, value)
	local ServerReturn
	pcall(function()
		ServerReturn = ServerControl:InvokeServer(mode, value)
	end)
	return ServerReturn
end

function OnClientInvoke(mode, value)
	if mode == "PlayAnimation" and value and ToolEquipped and Humanoid then
		SetAnimation("PlayAnimation", value)
	elseif mode == "StopAnimation" and value then
		SetAnimation("StopAnimation", value)
	elseif mode == "PlaySound" and value then
		value:Play()
	elseif mode == "StopSound" and value then
		value:Stop()
	elseif mode == "MouseData" then
		return ((PlayerMouse and {Position = PlayerMouse.Hit.p, Target = PlayerMouse.Target}) or nil)
	end
end

ClientControl.OnClientInvoke = OnClientInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXF33AC61AA9FE4A6A9BFC226A0BB575E2">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Remotes</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
					<Item class="RemoteFunction" referent="RBXF7F45A1396B04550BCF181655CB580A9">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ServerControl</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
						</Properties>
					</Item>
					<Item class="RemoteFunction" referent="RBX765C5DCF9A8F4837827C8FE1F31C23D7">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ClientControl</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
						</Properties>
					</Item>
				</Item>
				<Item class="Camera" referent="RBX5A49857B156A416FB4D5514A2A73F2AD">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<CoordinateFrame name="CFrame">
							<X>-1.73024595</X>
							<Y>5.56943798</Y>
							<Z>16.4627762</Z>
							<R00>-0.999122798</R00>
							<R01>-0.000657750061</R01>
							<R02>0.0418709926</R02>
							<R10>-0</R10>
							<R11>0.999876678</R11>
							<R12>0.0157070309</R12>
							<R20>-0.0418761559</R20>
							<R21>0.0156932529</R21>
							<R22>-0.998999596</R22>
						</CoordinateFrame>
						<Ref name="CameraSubject">null</Ref>
						<token name="CameraType">0</token>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="FieldOfView">40</float>
						<token name="FieldOfViewMode">0</token>
						<CoordinateFrame name="Focus">
							<X>-1.81398785</X>
							<Y>5.53802395</Y>
							<Z>18.4607735</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="HeadLocked">true</bool>
						<float name="HeadScale">1</float>
						<string name="Name">ThumbnailCamera</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<bool name="VRTiltAndRollEnabled">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		