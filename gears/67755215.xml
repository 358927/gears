<Item class="Model" referent="RBX35DDE304D48A4F88AC7BC6CA5909FE79">
			<Properties>
				<BinaryString name="AttributesSerialize" />
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">67755215</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags" />
				<OptionalCoordinateFrame name="WorldPivotData" />
			</Properties>
			<Item class="Camera" referent="RBX0321E8F0A76F4CD7A38741A7514924FE">
				<Properties>
					<BinaryString name="AttributesSerialize" />
					<CoordinateFrame name="CFrame">
						<X>2.12940407</X>
						<Y>58.0444565</Y>
						<Z>-2.1260519</Z>
						<R00>-0.493938953</R00>
						<R01>-0.180762559</R01>
						<R02>0.850499392</R02>
						<R10>-0</R10>
						<R11>0.978151441</R11>
						<R12>0.207893372</R12>
						<R20>-0.869496524</R20>
						<R21>0.102686636</R21>
						<R22>-0.483147144</R22>
					</CoordinateFrame>
					<Ref name="CameraSubject">null</Ref>
					<token name="CameraType">0</token>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<float name="FieldOfView">70</float>
					<token name="FieldOfViewMode">0</token>
					<CoordinateFrame name="Focus">
						<X>-4.13194752</X>
						<Y>56.5139503</Y>
						<Z>1.4308635</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="HeadLocked">true</bool>
					<float name="HeadScale">1</float>
					<string name="Name">ThumbnailCamera</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags" />
					<bool name="VRTiltAndRollEnabled">false</bool>
				</Properties>
			</Item>
			<Item class="Tool" referent="RBXFA715A45229B414FB07E1C8B025FB44E">
				<Properties>
					<BinaryString name="AttributesSerialize" />
					<bool name="CanBeDropped">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>0</X>
						<Y>-1.39999998</Y>
						<Z>-0.5</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>-0</R02>
						<R10>0</R10>
						<R11>0</R11>
						<R12>-1</R12>
						<R20>0</R20>
						<R21>1</R21>
						<R22>-0</R22>
					</CoordinateFrame>
					<token name="LevelOfDetail">0</token>
					<bool name="ManualActivationOnly">false</bool>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">SnowmanCannon</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<bool name="RequiresHandle">true</bool>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags" />
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=66703802</url></Content>
					<string name="ToolTip" />
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>0</X>
							<Y>57.4000015</Y>
							<Z>0</Z>
							<R00>0.961553633</R00>
							<R01>-0.274494171</R01>
							<R02>0.00826891419</R02>
							<R10>-0.00516340323</R10>
							<R11>0.0120347124</R11>
							<R12>0.999914169</R12>
							<R20>-0.274570346</R20>
							<R21>-0.96151334</R21>
							<R22>0.0101543553</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="LocalScript" referent="RBX39211AF3A69246C69708FB667058D956">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">SnowmanCannon_MainScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{2303381A-C08E-42A6-BEB5-E31F7E5A7028}</string>
						<ProtectedString name="Source">--local mDebugId = game.Workspace.DebugId.Value
--game.Workspace.DebugId.Value = game.Workspace.DebugId.Value+1
--print("Running swordscript &lt;"..mDebugId.."&gt;")

-------------------------------------
-- Makes an RBX::Lua Instance using
-- a table of key-value pairs to
-- initialize it. Values with numeric
-- keys will be parented to the object
-- and other values will be set
-- as members of the object.
function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

---------------------------------------
-- Same as Make, but modifies an existing
-- object rather than creating ones.
function Modify(obj, data)
	for k, v in pairs(data) do
		if type(data) == 'number' then
			data.Parent = obj
		else
			data[k] = v
		end
	end
	return obj
end

-----------------------------------------
-- Creates a class which can be instantiated
-- using `CreateCLASSNAME( ... )`.
---usage:
--class'MyClass'(function(this, arg1)
--	this.ClassMember = value
--	function this.ClassMethod(...) ... end
--end, function(def)
--	def.StaticMember = value
--	 function def.StaticMethod(...) ... end
--end)
--local obj = CreateMyClass(arg1)
------------------------------------------
local function class(name)
	local def = {}
	getfenv(0)[name] = def
	return function(ctor, static)
		local nctor = function(...)
			local this = {}
			if ctor then
				ctor(this, ...)
			end
			return this
		end
		getfenv(0)['Create'..name] = nctor
		if static then static(def) end
	end
end


---------------------------------------------
-- Signal class for custom-made events
--API:
-- Signal:connect(callback)
-- Signal:fire(...)
-- Signal:wait()
---------------------------------------------
class'Signal'(function(this)
	local mListeners = {}
	local mWaitObject = Create'BoolValue'{}

	function this:connect(func)
		local connection = {}
		function connection:disconnect()
			mListeners[func] = nil
		end
		mListeners[func] = connection
		return connection
	end

	function this:fire(...)
		--print("Fire evt&lt;"..tostring(this).."&gt; from script&lt;"..mDebugId.."&gt;")
		for func, conn in pairs(mListeners) do
			--print("-&gt; "..tostring(func).."( ... )")
			func(...)
		end
		mWaitObject.Value = not mWaitObject.Value
	end

	function this:wait()
		mWaitObject.Changed:wait()
	end
end)


--------------------------------------------------
-- Bin class for cleaning up assets
--API:
-- Bin:add(func: Function, ident: String)
-- Bin:clean(ident: String)
-- Bin:cleanAll()
--------------------------------------------------
class'Bin'(function(this)
	local mGarbage = {}

	function this:add(func, ident)
		ident = ident or '__unnamed'
		if not mGarbage[ident] then
			mGarbage[ident] = {}
		end
		mGarbage[ident][#mGarbage[ident]+1] = func
	end

	function this:clean(ident)
		local listToCall = mGarbage[ident]
		if listToCall then
			for _, func in pairs(listToCall) do
				func()
			end
			mGarbage[ident] = nil
		end
	end

	function this:cleanAll()
		for ident, list in pairs(mGarbage) do
			for _, func in pairs(list) do
				func()
			end
			mGarbage[ident] = nil
		end
	end
end)


-----------------------------------------------------
-- AnimationProvider class for easy loading of
-- animation assets into animationtracks once
-- a humanoid is available.
--API:
-- AnimationProvider:registerAnimation(ident, assetid)
-- AnimationProvider:setHumanoid(humanoid)
-- AnimationProvider:setTool(tool)
-- AnimationProvider:getAnimation(ident)
-----------------------------------------------------
class'AnimationProvider'(function(this)
	local mAnimations = {--[[ident =&gt; {AnimationId, CurrentTrack, CurrentAnim} ]]}
	local mCurrentHumanoid = nil

	function this:registerAnimation(ident, assetid)
		--check for an existing copy of the anim
		local existingAnim = Tool.Tool:FindFirstChild('ANIM_'..ident)

		--make the data for this anim
		local animdat = {
			AnimationId = assetid,
			CurrentAnim = existingAnim or Create'Animation'{
				Name = "ANIM_"..ident,
				AnimationId = assetid,
			},
		}
		mAnimations[ident] = animdat

		--if there's a current tool, put it in there
		if Tool.Tool then
			Tool.HUGE_EQUIP_HACK = true
			animdat.CurrentAnim.Parent = Tool.Tool
			Tool.HUGE_EQUIP_HACK = false
		end

		--if there's a humanoid load the animation track
		if mCurrentHumanoid then
			animdat.CurrentTrack = mCurrentHumanoid:LoadAnimation(animdat.CurrentAnim)
		end
	end

	function this:setHumanoid(humanoid)
		mCurrentHumanoid = humanoid
		for _, anim in pairs(mAnimations) do
			anim.CurrentTrack = humanoid:LoadAnimation(anim.CurrentAnim)
		end
	end

	function this:getAnimation(ident)
		local dat = mAnimations[ident]
		if not dat then error("Gear Fatal Error: Animation `"..ident.."` not found") end
		if not dat.CurrentTrack then
			error("Gear Fatal Error: No Humanoid for animation `"..ident.."` to run in")
		end
		return dat.CurrentTrack
	end
end)


----------------------------------------------
-- SoundProvider class
-- functions similarily to the animationprovider
----------------------------------------------
class'SoundProvider'(function(this)
	local mSounds = {}

	function this:registerSound(ident, assetid, inpart)
		inpart = inpart or Tool.Tool:FindFirstChild('Handle')
		if not inpart then
			repeat
				inpart = Tool.Tool.ChildAdded:wait()
			until inpart.Name == 'Handle'
		end
		local existingSound = inpart:FindFirstChild('SOUND_'..ident)
		local sounddat = {
			SoundId = assetid,
			CurrentSound = existingSound or Create'Sound'{
				Name = 'SOUND_'..ident,
				SoundId = assetid,
				Parent = inpart,
			},
		}
		mSounds[ident] = sounddat
	end

	function this:getSound(ident)
		local dat = mSounds[ident]
		if dat then
			return dat.CurrentSound
		end
	end
end)


----------------------------------------------
-- DebounceProvider class -- Prevent events
-- from happening in too rapid succession
----------------------------------------------
class'DebounceProvider'(function(this)
	local mFlagNameToLastTime = {}

	function this:test(ident, delta)
		local t = tick()
		local lastTime = mFlagNameToLastTime[ident] or 0
		if delta then
			return (t-lastTime) &gt; delta
		else
			return mFlagNameToLastTime[ident]
		end
	end
	function this:set(ident, state)
		if state then
			mFlagNameToLastTime[ident] = state
		elseif state == false then
			mFlagNameToLastTime[ident] = false
		else
			mFlagNameToLastTime[ident] = tick()
		end
	end
end)


function TagHumanoid(humanoid)
	if Tool.Player then
		local tag = Create'ObjectValue'{
			Name = "creator",
			Value = Tool.Player,
			Parent = humanoid,
		}
		Tool.Bin:add(function()
			tag:Remove()
		end, 'HumanoidTag')
	end
end
function UntagHumanoid()
	Tool.Bin:clean('HumanoidTag')
end


------- wait for any event in a set of events  to fire ------
function WaitForAny(tb)
	local evt = tb
	local conn = {}
	local eventargs = nil
	local waitProxy = Create'BoolValue'{}
	for _, e in pairs(evt) do
		local c = e:connect(function(...)
			for _, c in pairs(conn) do
				c:disconnect()
			end
			eventargs = {...}
			waitProxy.Value = not waitProxy.Value
		end)
		conn[#conn+1] = c
	end
	--
	waitProxy.Changed:wait()
	--
	return unpack(eventargs)
end


----------------------------------------------
-- Tool singleton class
--API:
-- ...
class'Tool'(nil, function(this)
	--need this here for the animationprovider to use
	this.HUGE_EQUIP_HACK = false

	this.Bin = CreateBin()
	this.AnimationProvider = CreateAnimationProvider()
	this.DebounceProvider = CreateDebounceProvider()
	this.SoundProvider = CreateSoundProvider()

	--general values
	this.Tool = script.Parent
	this.Player = nil
	this.Humanoid = nil
	this.Character = nil

	--============ several flags for the gear
	--nothing

	--some events
	this.Equipped = CreateSignal()
	this.Unequipped = CreateSignal()
	this.OwnerChange = CreateSignal()

	--mouse utility events
	this.MouseClick = CreateSignal()
	this.MouseDoubleClick = CreateSignal()
	this.DoubleClickThreshold = 0.2
	this.MouseDown = false
	this.KeyDown = CreateSignal()

	local mLastClickTime = 0

	script.Parent.Equipped:connect(function(mouse)
		--print("Internal Equipped: Time b: "..time())
		--set up general values in the tool
		this.Mouse = mouse
		local curOwner = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
		if curOwner ~= this.Player then
			this.Player = curOwner
			this.OwnerChange:fire(this.Player)
		end
		this.Character = this.Player.Character
		this.Humanoid = this.Character.Humanoid
		this.AnimationProvider:setHumanoid(this.Humanoid)

		--set up the mouse events
		mouse.Button1Down:connect(function()
			this.MouseDown = true
			local t = tick()
			if (t-mLastClickTime) &lt; this.DoubleClickThreshold then
				--prvent multiple double-clicks in a row
				mLastClickTime = 0
				this.MouseDoubleClick:fire(mouse)
			else
				mLastClickTime = t
				this.MouseClick:fire(mouse)
			end
		end)
		mouse.Button1Up:connect(function()
			this.MouseDown = false
		end)
		mouse.KeyDown:connect(function(key)
			this.KeyDown:fire(key)
		end)

		--done setup, call the equipped function
		if this.HUGE_EQUIP_HACK then
			--the HUGE_EQUIP_HACK flags tells the tool that the equip is a synchronous
			--call as a result of parenting an animation to the character, which happens
			--when the tool is picked up from the workspace, but not during normal equips
			--(Why does this happen???), if this is the case, the call should be rederrred
			--one tick to ensure that all of the gear's loading can complete before it's
			--equipped event is called.
			--TODO: Blame John for this.
			Delay(0, function()
				this.Equipped:fire(mouse)
			end)
		else
			--otherwise, proceed as normal
			this.Equipped:fire(mouse)
		end
	end)

	script.Parent.Unequipped:connect(function()
		--before my teardown, fire the event
		this.Unequipped:fire()

		--delete all my garbage
		this.Bin:cleanAll()
	end)
end)


local CurrentToolMode = nil

local function SetToolMode(mode)
	if CurrentToolMode then
		CurrentToolMode.onDeselect()
	end
	CurrentToolMode = mode
	if mode then
		mode.onSelect()
	end
end
local CreateMode = nil
local TargetMode = nil

-------------------------------------------
---------- interface in player ------------
local TargetValue = nil
local SnowmanListModel = nil
local function SetTarget(humanoid)
	TargetValue.Value = humanoid
end


-------------------------------------------
---------------- settings -----------------
class'ToolSettings'(nil, function(def)
	def.MaxSnowmanCount = 3
	def.CreationTime = 1 --1 second
	def.MaxRange = 30
end)


-------------------------------------------
-- isolated "flash lasso effect" class which
-- can be reused in other gear in the future
-- API:
-- FlashLasso(from, to, brickcolor):
--  Creates a new flashlasso between a |from|
--  and a |to| position with a given |brickcolor|
--
-- setTransparency(factor):
--  Sets the transparency of the effect. Usefull
--  for fading the effect in-out if desired.
--
-- destroy():
--  Cleans up any resources the FlashLasso may
--  have put into the workspace or other
--  locations.
-------------------------------------------
class'FlashLasso'(function(this, from, to, color)
	local mRunFlag = true
	local mTransparency = 0

	--
	local K = (2*math.pi)/5
	local Omega = (2*math.pi)*6
	local function GetMainBeamDisp(x, t)
		return (math.cos(K*x - Omega*t)+math.cos(K*x - (0.2*Omega)*t))*0.2,
		       (math.sin(K*x - Omega*t)+math.cos(K*x - (0.2*Omega)*t))*0.2
	end

	--
	local mBeamDir = CFrame.new(from, to)
	local mBeamLength = (to-from).magnitude
	--
	local mMainBeamSegCount = math.ceil(mBeamLength/FlashLasso.DesiredSegSize)
	local mMainBeamSegLen = mBeamLength/mMainBeamSegCount
	local mMainBeamSegs = {}
	for i = 1, mMainBeamSegCount do
		mMainBeamSegs[i] = Create'Part'{
			Name = 'BeamSeg',
			Parent = game.Workspace,
			Anchored = true,
			CanCollide = false,
			Archivable = false,
			FormFactor = 'Custom',
			Transparency = FlashLasso.BeamTransparency,
			BrickColor = color,
			BottomSurface = 'Smooth',
			TopSurface = 'Smooth',
		}
	end

	local function SetMainBeamState(t)
		local xysize = FlashLasso.BeamRadius*2
		for i = 1, mMainBeamSegCount do
			local seg = mMainBeamSegs[i]
			local z1 = (i-1)*mMainBeamSegLen
			local x1, y1 = GetMainBeamDisp(z1, t)
			local z2 = (i)*mMainBeamSegLen
			local x2, y2 = GetMainBeamDisp(z2, t)
			--
			local p1 = (mBeamDir*CFrame.new(x1, y1, -z1)).p
			local p2 = (mBeamDir*CFrame.new(x2, y2, -z2)).p
			--
			seg.Size = Vector3.new(xysize, xysize, (p1-p2).magnitude)
			seg.CFrame = CFrame.new(0.5*(p1+p2), p2)
		end
	end
	SetMainBeamState(tick())

	local mSparkSegs = {}
	local function MoveSparkSegs()
		local xysize = FlashLasso.BeamRadius*1.5
		for seg, _ in pairs(mSparkSegs) do
			if math.random(1, 20) == 20 or seg.Z &gt; mBeamLength then
				mSparkSegs[seg] = nil
				seg.Part.Parent = nil
			else
				local nz = seg.Z+seg.Length
				local nx = (math.random(-5,5)/10)
				local ny = (math.random(-5,5)/10)
				--
				local po = (mBeamDir*CFrame.new(seg.LastX, seg.LastY, -seg.Z)).p
				local pn = (mBeamDir*CFrame.new(nx, ny, -nz)).p
				--
				seg.Z = nz
				seg.LastX = nx
				seg.LastY = ny
				seg.Part.Size = Vector3.new(xysize, xysize, (po-pn).magnitude)
				seg.Part.CFrame = CFrame.new(0.5*(po+pn), pn)
			end
		end
	end

	Spawn(function()
		while mRunFlag do
			SetMainBeamState(tick())

			--make a spark
			local spark = {}
			spark.Z = 0
			spark.LastX = 0
			spark.LastY = 0
			spark.Length = math.random(2, 4)
			spark.Part = Create'Part'{
				Name = 'BeamSeg',
				Parent = game.Workspace,
				Anchored = true,
				CanCollide = false,
				Archivable = false,
				FormFactor = 'Custom',
				Transparency = (1-((1-FlashLasso.SparkTransparency)*(1-mTransparency))),
				BrickColor = color,
				BottomSurface = 'Smooth',
				TopSurface = 'Smooth',
				Size = Vector3.new(FlashLasso.BeamRadius*2,
				                   FlashLasso.BeamRadius*2,
				                   spark.Length),
			}
			mSparkSegs[spark] = true

			MoveSparkSegs()

			wait()
		end
	end)

	function this:destroy()
		mRunFlag = false
		for _, p in pairs(mMainBeamSegs) do
			p.Parent = nil
		end
		for seg, _ in pairs(mSparkSegs) do
			seg.Part.Parent = nil
		end
	end

	function this:setTransparency(f)
		local mainTrans = 1-((1-FlashLasso.BeamTransparency)*(1-f))
		for _, seg in pairs(mMainBeamSegs) do
			seg.Transparency = mainTrans
		end
		local sparkTrans = 1-((1-FlashLasso.SparkTransparency)*(1-f))
		for seg, _ in pairs(mSparkSegs) do
			seg.Part.Transparency = sparkTrans
		end
		mTransparency = f
	end

end, function(def)
	def.DesiredSegSize = 2
	def.BeamTransparency = 0.5
	def.SparkTransparency = 0
	def.BeamRadius = 0.2
end)


-------------------------------------------
---------- listen for events --------------
Tool.Equipped:connect(function(mouse)
	--set up interface
	if not Tool.Player:FindFirstChild('SnowmanGun_Target') then
		Create'ObjectValue'{
			Parent = Tool.Player,
			Name = 'SnowmanGun_Target',
		}
	end
	TargetValue = Tool.Player:FindFirstChild('SnowmanGun_Target')

	if not Tool.Player:FindFirstChild('SnowmanGun_SnowmanList') then
		Create'Model'{
			Parent = Tool.Player,
			Name = 'SnowmanGun_SnowmanList',
		}
	end
	SnowmanListModel = Tool.Player:FindFirstChild('SnowmanGun_SnowmanList')

	--
	SetToolMode(CreateMode)
end)
Tool.Unequipped:connect(function()
	SetToolMode(nil)
end)
Tool.MouseClick:connect(function(mouse)
	CurrentToolMode.onPress(mouse)
end)
Tool.KeyDown:connect(function(key)
	if key:lower() == 'e' then
		SetToolMode(CreateMode)
	elseif key:lower() == 'q' then
		SetToolMode(TargetMode)
	end
end)


-------------------------------------------
--------- shared gui between modes --------
local Gui = Create'ScreenGui'{
	Name = 'SnowmanGunGui',
}
local ModeGui = Create'Frame'{
	Parent = Gui,
	--
	Name = 'ModeSelect',
	Style = 'RobloxRound',
	Size = UDim2.new(0, 128, 0, 256),
	Position = UDim2.new(0, 16, 0.5, -128),
	Create'TextButton'{
		Name = 'SetMode_Create',
		Style = 'RobloxButton',
		Size = UDim2.new(1, 0, 0.5, 0),
		Position = UDim2.new(),
		Font = 'Arial',
		TextColor3 = Color3.new(1,1,1),
		FontSize = 'Size18',
		Text = "Create\nMode\n(`E` Key)",
		TextWrap = true,
	},
	Create'TextButton'{
		Name = 'SetMode_Target',
		Style = 'RobloxButton',
		Size = UDim2.new(1, 0, 0.5, 0),
		Position = UDim2.new(0, 0, 0.5, 0),
		Font = 'Arial',
		TextColor3 = Color3.new(1,1,1),
		FontSize = 'Size18',
		Text = "Target\nMode\n(`Q` Key)",
		TextWrap = true,
	},
}
ModeGui.SetMode_Create.MouseButton1Down:connect(function()
	SetToolMode(CreateMode)
end)
ModeGui.SetMode_Target.MouseButton1Down:connect(function()
	SetToolMode(TargetMode)
end)

local CreationProgressGui = Create'Frame'{
	Parent = Gui,
	Visible = false,
	--
	Name = 'CreationProgress',
	Style = 'RobloxRound',
	Size = UDim2.new(0, 256, 0, 64),
	Position = UDim2.new(0.5, -128, 0, 16),
	--
	Create'TextLabel'{
		Name = 'ProgressLabel',
		Text = "",
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
		TextColor3 = Color3.new(1, 1, 1),
		Font = 'Arial',
		FontSize = 'Size14',
	},
}

local TargetGui = Create'BillboardGui'{
	Name = 'SnowmanGun_Targeter',
	--
	Create'ImageLabel'{
		Visible = false,
		Name = 'TrackerImage',
		Image = 'http://www.roblox.com/asset/?id=66740738',
		Size = UDim2.new(9, 0, 9, 0),
		Position = UDim2.new(-4, 0, -4, 0),
		BackgroundTransparency = 1,
	},
	--
	Size = UDim2.new(1, 0, 1, 0),
	AlwaysOnTop = true,
}

local LabelMessageUid = 0
local function UnsetCreationProgressLabel()
	CreationProgressGui.ProgressLabel.Text = "Click and hold to create snowman turrets!"
end
local function SetCreationProgressLabel(frac)
	LabelMessageUid = LabelMessageUid + 1
	local muid = LabelMessageUid
	--
	if type(frac) == 'number' then
		local perc = tostring(frac*100):sub(1,3).."%"
		CreationProgressGui.ProgressLabel.Text = "Creating... "..perc
	elseif type(frac) == 'string' then
		CreationProgressGui.ProgressLabel.Text = frac
	end
	--
	return function()
		if LabelMessageUid == muid then
			UnsetCreationProgressLabel()
		end
	end
end


-------------------------------------------
----------- utility functions -------------
local function GetFireFrom() --get the position of the tip of the weapon
	return (Tool.Tool.Handle.CFrame * CFrame.new(-0.2, 1.8, 0.05)).p
end

local function ClassifySurface(part, point)
	local psize = part.Size
	local reldif = part.CFrame:toObjectSpace(CFrame.new(point)).p - psize/2
	local xdif = math.min(math.abs(reldif.x - psize.x), math.abs(reldif.x))
	local ydif = math.min(math.abs(reldif.y - psize.y), math.abs(reldif.y))
	local zdif = math.min(math.abs(reldif.z - psize.z), math.abs(reldif.z))
	if xdif &lt; math.min(ydif, zdif) then
		if math.abs(reldif.x - psize.x) &lt; reldif.x then
			return Enum.NormalId.Left
		else
			return Enum.NormalId.Right
		end
	elseif ydif &lt; math.min(xdif, zdif) then
		if math.abs(reldif.y - psize.y) &lt; reldif.y then
			return Enum.NormalId.Bottom
		else
			return Enum.NormalId.Top
		end
	elseif zdif &lt; math.min(xdif, ydif) then
		if math.abs(reldif.z - psize.z) &lt; psize.z then
			return Enum.NormalId.Front
		else
			return Enum.NormalId.Back
		end
	end
end

local function IsAbove(part, point)
	local normal = ClassifySurface(part, point)
	return ((part.CFrame-part.CFrame.p)*Vector3.FromNormalId(normal)).y &gt; 0
end

local function GetSnowmanList()
	local snowmen = {}
	for _, sn in pairs(SnowmanListModel:GetChildren()) do
		snowmen[#snowmen+1] = sn.Value
	end
	return snowmen
end


-------------------------------------------
----------- create snowmen mode -----------
CreateMode = {}
function CreateMode.onPress(mouse)
	--do a raycast to find the true hit position of the shot
	local dirray = Ray.new(GetFireFrom(), (mouse.Hit.p-GetFireFrom()).unit*10000)
	local obj, pos = game.Workspace:FindPartOnRay(dirray, Tool.Character)

	--no hit object? Just bail out
	if not obj then return end

	--if the hit isn't close enough then bail out
	if (pos-GetFireFrom()).magnitude &gt; ToolSettings.MaxRange then
		--show a failed message
		local unsetLabel = SetCreationProgressLabel("Target not in range!")
		Delay(1, unsetLabel)

		--show a failed shot thing to show the range
		local failedFlash = CreateFlashLasso(GetFireFrom(),
		                                     GetFireFrom()+(pos-GetFireFrom()).unit*ToolSettings.MaxRange,
		                                     BrickColor.new(23))
		--add it to the bin to make sure it gets removed
		Tool.Bin:add(function()
			failedFlash:destroy()
		end, 'kill_failed_shot_effect')

		--now, fade it out
		for i = 0, 1, 0.1 do
			failedFlash:setTransparency(i)
			wait()
		end

		--and clean up
		Tool.Bin:clean('kill_failed_shot_effect')
		return
	end

	--I hit something
	if obj.Parent and obj.Parent:FindFirstChild('SnowmanOwner') then
		--fired at a snowman
		if obj.Parent.SnowmanOwner.Value == Tool.Player then
			local snowman_hum = obj.Parent.Humanoid
			--fired at one of my own snowmen, delete it
			SetCreationProgressLabel("Deleting...")

			--effect for a glow where the snowman is being created
			local deletionGlow = Create'Part'{
				Parent = game.Workspace,
				--
				Name = 'DeleteSnowmanGlow',
				Transparency = 1,
				Anchored = true,
				Archivable = false,
				CFrame = CFrame.new(pos),
				--
				Create'Fire'{
					Name = 'GlowEffect',
					Color = Color3.new(1, 0.2, 0.2),
					Size = 3,
				},
			}
			local deletionFlash = CreateFlashLasso(GetFireFrom(), pos, BrickColor.new(21))

			--slow down the character
			Tool.Humanoid.WalkSpeed = 0

			--set up clean-up
			Tool.Bin:add(function()
				deletionFlash:destroy()
				deletionGlow.Parent = nil
				UnsetCreationProgressLabel()
				Tool.Humanoid.WalkSpeed = 16
			end, 'destroy_deletion_effects')

			--kill
			while Tool.MouseDown and snowman_hum.Health &gt; 0 do
				snowman_hum:TakeDamage(2)
				wait()
			end
			UnsetCreationProgressLabel()

			--done, fade out effects
			deletionGlow.Parent = nil
			for i = 0, 1, 0.1 do
				deletionFlash:setTransparency(i)
				wait()
			end

			--clean up
			Tool.Bin:clean('destroy_deletion_effects')
		end
	else
		--check that there aren't too many snowmen
		if #GetSnowmanList() &gt;= ToolSettings.MaxSnowmanCount then
			local unsetLabel = SetCreationProgressLabel("You have too many snowmen currently created!")
			Delay(1, unsetLabel)
			return
		end

		--fired somewhere else, see if I hit a relatively horizontal surface
		--that a snowman can be placed on. Surface could also be a terrain, and
		--unfortunately there's no sane way to check if that's a relatively
		--horisontal surface, so don't.
		if obj:IsA('Terrain') or IsAbove(obj, pos) then
			--all good, go to create a snowman.

			--effect for a glow where the snowman is being created
			local creationGlow = Create'Part'{
				Parent = game.Workspace,
				--
				Name = 'CreateSnowmanGlow',
				Transparency = 1,
				Anchored = true,
				Archivable = false,
				CFrame = CFrame.new(pos),
				--
				Create'Fire'{
					Name = 'GlowEffect',
					Color = Color3.new(0.2, 0.2, 1),
					Size = 3,
				},
			}

			--effect for a line going from the gun to the snowman
			local creationLasso = CreateFlashLasso(GetFireFrom(), pos, BrickColor.new(23))

			--slow down the character
			Tool.Humanoid.WalkSpeed = 0

			--clean them up if all else fails
			Tool.Bin:add(function()
				creationGlow.Parent = nil
				creationLasso:destroy()
				UnsetCreationProgressLabel()
				Tool.Humanoid.WalkSpeed = 16
			end, 'destroy_creation_effects')

			SetCreationProgressLabel(0)
			for t = 0, ToolSettings.CreationTime, 0.1 do
				wait(0.1)
				if Tool.MouseDown then
					SetCreationProgressLabel(t/ToolSettings.CreationTime)
				else
					--if they released the mouse then bail out
					UnsetCreationProgressLabel()
					Tool.Bin:clean('destroy_creation_effects')
					return
				end
			end

			--finished the wait, do the creation
			local snowMan = Create'Model'{
				Name = Tool.Player.Name..'\'s Snowman',
				Create'Part'{
					Name = 'Head',
					FormFactor = 'Custom',
					Size = Vector3.new(1.2, 1.1, 1.2),
					BrickColor = BrickColor.new(1002), --`Mid gray`
					Create'SpecialMesh'{}, --The headmesh, defaults are correct
				},
				Create'Part'{
					Name = 'Mid',
					FormFactor = 'Custom',
					Size = Vector3.new(1.4, 1.2, 1.4),
					BrickColor = BrickColor.new(1002),
					Create'SpecialMesh'{},
					Create'Motor6D'{Name='RightGun'},
					Create'Motor6D'{Name='LeftGun'},
				},
				Create'Part'{
					Name = 'Torso',
					FormFactor = 'Custom',
					Size = Vector3.new(1.6, 1.3, 1.6),
					BrickColor = BrickColor.new(1002),
					Create'SpecialMesh'{},
					Create'Motor6D'{
						Name = 'Neck',
					},
					Create'Motor6D'{
						Name = 'Hip',
					},
					Create'Sound'{
						Name = 'FireSnowball',
						SoundId = 'rbxasset://sounds//paintball.wav',
					},
				},
				Create'Part'{
					Name = 'RightGun',
					FormFactor = 'Custom',
					Size = Vector3.new(0.4, 0.6, 1.5),
					BrickColor = BrickColor.new(1003), --`Really black`
				},
				Create'Part'{
					Name = 'LeftGun',
					FormFactor = 'Custom',
					Size = Vector3.new(0.4, 0.6, 1.5),
					BrickColor = BrickColor.new(1003), --`Really black`
				},
				Create'ObjectValue'{
					Name = 'SnowmanOwner',
					Value = Tool.Player,
				}
			}
			snowMan.Torso.Neck.Part0 = snowMan.Torso
			snowMan.Torso.Neck.Part1 = snowMan.Head
			snowMan.Torso.Neck.C0 = CFrame.new(0, 2.2, 0)
			snowMan.Torso.Hip.Part0 = snowMan.Torso
			snowMan.Torso.Hip.Part1 = snowMan.Mid
			snowMan.Torso.Hip.C0 = CFrame.new(0, 1.2, 0)
			--
			snowMan.Mid.RightGun.Part0 = snowMan.Mid
			snowMan.Mid.RightGun.Part1 = snowMan.RightGun
			snowMan.Mid.RightGun.C0 = CFrame.new(0.8, 0, 0)
			snowMan.Mid.LeftGun.Part0 = snowMan.Mid
			snowMan.Mid.LeftGun.Part1 = snowMan.LeftGun
			snowMan.Mid.LeftGun.C0 = CFrame.new(-0.8, 0, 0)

			--now that the thing is aset up for a humanoid, make it
			Create'Humanoid'{Parent = snowMan,}

			--put it where it need to be and register to to the player
			snowMan.Parent = game.Workspace
			snowMan.Torso.Anchored = true
			snowMan.Torso.CFrame = CFrame.new(pos + Vector3.new(0, 0.7, 0))
			Create'ObjectValue'{
				Parent = SnowmanListModel,
				Value = snowMan,
			}

			--finally, activate the snowman with a script, also put a copy of the
			--bulletdamage script into it that it can use to put into bullets
			local sc = Tool.Tool.SnowmanScript:Clone()
			sc.Parent = snowMan
			sc.Disabled = false
			local dmg = Tool.Tool.BulletDamage:Clone()
			dmg.Parent = snowMan

			--fade out the effect
			creationGlow.Parent = nil
			for i = 0, 1, 0.1 do
				creationLasso:setTransparency(i)
				wait()
			end

			--clean up
			Tool.Bin:clean('destroy_creation_effects')
		end
	end
end
function CreateMode.onSelect()
	Gui.Parent = Tool.Player.PlayerGui
	CreationProgressGui.Visible = true
	UnsetCreationProgressLabel()
end
function CreateMode.onDeselect()
	CreationProgressGui.Visible = false
	Gui.Parent = nil
end


-------------------------------------------
-----------  set target mode    -----------
TargetMode = {}
local ToolSelected = false
function TargetMode.onPress()
	local t = Tool.Mouse.Target
	local hum = (t.Parent or game):FindFirstChild('Humanoid')
	if hum then
		--clicked a humanoid, target it and show the target gui
		TargetValue.Value = hum

		--find a part in the humanoid to attach the gui to
		local partToAttachTo = (hum.Parent or game):FindFirstChild('Torso')
		if not partToAttachTo and hum.Parent then
			local largestPart = nil
			for _, p in pairs(hum.Parent:GetChildren()) do
				if p:IsA('BasePart') then
					if not largestPart or p.Size.magnitude &gt; largestPart.Size.magnitude then
						largestPart = p
					end
				end
			end
			partToAttachTo = largestPart
		end
		if partToAttachTo then
			TargetGui.TrackerImage.Visible = true
			TargetGui.Adornee = partToAttachTo
		else
			TargetGui.TrackerImage.Visible = false
		end
	end
end
function TargetMode.onSelect()
	ToolSelected = true
	Gui.Parent = Tool.Player.PlayerGui
	--
	TargetGui.TrackerImage.Visible = true
	TargetGui.Parent = Tool.Player.PlayerGui
	--
	while ToolSelected do
		local t = Tool.Mouse.Target
		if t then
			local hum = (t.Parent or game):FindFirstChild('Humanoid')
			hum = hum or ((t.Parent or game).Parent or game):FindFirstChild('Humanoid')
			if hum then
				Tool.Mouse.Icon = 'http://www.roblox.com/asset/?id=66740738'
			else
				Tool.Mouse.Icon = 'http://www.roblox.com/asset/?id=66740715'
			end
		else
			Tool.Mouse.Icon = 'http://www.roblox.com/asset/?id=66740715'
		end
		wait()
	end
end
function TargetMode.onDeselect()
	TargetGui.TrackerImage.Visible = false
	TargetGui.Parent = nil
	--
	ToolSelected = false
	Tool.Mouse.Icon = ''
	Gui.Parent = nil
end
</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBXD1604AB00515471499F4646FED0C4140">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">SnowmanScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{3D652054-A72B-4F21-B37C-9F40AB22C743}</string>
						<ProtectedString name="Source">-------------------------------------
-- Makes an RBX::Lua Instance using
-- a table of key-value pairs to
-- initialize it. Values with numeric
-- keys will be parented to the object
-- and other values will be set
-- as members of the object.
function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

---------------------------------------------------------------------------
---------------------------------------------------------------------------
--                                                                       --
--                        main code starts here                          --
--                                                                       --
---------------------------------------------------------------------------
---------------------------------------------------------------------------

local Snowman = script.Parent
local Humanoid = Snowman.Humanoid
local Owner = Snowman.SnowmanOwner.Value
local Target = Owner:FindFirstChild('SnowmanGun_Target') or
               Instance.new('ObjectValue') --just in case the map I'm in is doing something terrible,
                                           --I want to maintain function and not leave these as garbage
                                           --in the workspace.

local Mid = Snowman.Mid
local Torso = Snowman.Torso
local Hip = Snowman.Torso.Hip
local RightGun = Snowman.Mid.RightGun
local LeftGun = Snowman.Mid.LeftGun

game.Players.ChildRemoved:connect(function(p)
	if p == Owner then
		Humanoid.Health = 0
	end
end)

Humanoid.Died:connect(function()
	--on died, unregister self from owners list of things
	if Owner:FindFirstChild('SnowmanGun_SnowmanList') then
		for _, ch in pairs(Owner.SnowmanGun_SnowmanList:GetChildren()) do
			if ch.Value == Snowman then
				ch.Parent = nil
				break
			end
		end
	end
	--fade my parts to transprent
	for i = 0, 1, 0.1 do
		for _, obj in pairs(Snowman:GetChildren()) do
			if obj:IsA('BasePart') then
				obj.Transparency = i
			end
		end
		wait(0.1)
	end
	--and finally remove self
	Snowman:Remove()
end)

function BumpModel()
	Torso.CFrame = Torso.CFrame * CFrame.new(0, 1, 0)
	Torso.CFrame = Torso.CFrame * CFrame.new(0, -1, 0)
end

local LastShotTime = 0
local ReloadTime = 2
local MaxRange = 100

while true do
	wait()
	local t = Target.Value
	if t and t:IsA('Humanoid') and t ~= Humanoid then
		local torso = (t.Parent or game):FindFirstChild('Torso')
		if torso and t.Health &gt; 0 then
			--aim and fire!
			local aimPos = torso.Position
			local desiredCFrame = CFrame.new(Mid.Position, Vector3.new(aimPos.x, Mid.Position.y, aimPos.z))
			Hip.C1 = desiredCFrame:inverse()*Torso.CFrame*Hip.C0

			--todo: aim the guns as well
			BumpModel() --show the changes

			--find distance. Note: this code is here as the turret should still aim even if
			--it is not going to fire!
			local distToTarget = (Mid.Position-aimPos).magnitude

			if (tick()-LastShotTime) &gt; ReloadTime and distToTarget &lt; MaxRange then
				--fire a shot
				local Shot = Create'Part'{
					Name = 'SnowmanBullet',
					Shape = 'Ball',
					FormFactor = 'Custom',
					Size = Vector3.new(0.8, 0.8, 0.8),
					BrickColor = BrickColor.new(1002),
					CanCollide = false,
					CFrame = Mid.CFrame,
					Create'ObjectValue'{
						Name = 'CreatorSnowman',
						Value = Snowman,
					},
					Create'SpecialMesh'{
						Name = 'Mesh',
						MeshId = 'http://www.roblox.com/asset/?id=66733658',
					},
					Create'BodyVelocity'{
						Name = 'Propell',
						velocity = CFrame.new(Mid.Position, aimPos).lookVector*60,
						maxForce = Vector3.new(10000, 10000, 10000),
					},
				}

				--put a damage script in it
				local dmg = Snowman.BulletDamage:Clone()
				dmg.Parent = Shot
				dmg.Disabled = false

				--throw it into the workspace
				Shot.Parent = game.Workspace

				--play the fire sound
				Torso.FireSnowball:Play()

				--set the reload
				LastShotTime = tick()
			end
		end
	end
end</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBXBB934D2501B44A3489749B1C42DE3BC2">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">BulletDamage</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{246DC1C1-EB43-469F-8E79-C54DFA816ED8}</string>
						<ProtectedString name="Source">local CreatorSnowman = script.Parent.CreatorSnowman.Value
local CreatorPlayer = CreatorSnowman.SnowmanOwner.Value

function TagHumanoid(humanoid)
	local tag = Instance.new('ObjectValue')
	tag.Name = "creator"
	tag.Value = CreatorPlayer
	tag.Parent = humanoid
end
function UntagHumanoid(humanoid)
	if humanoid:FindFirstChild("creator") then
		humanoid.creator.Parent = nil
	end
end

local DamageToDo = 20

script.Parent.Touched:connect(function(part)
	--ignore touching the creator itself
	if not part:IsDescendantOf(CreatorSnowman) then
		local hum = (part.Parent or game):FindFirstChild('Humanoid')
		--catch hats and handles too
		hum = hum or ((part.Parent or game).Parent or game):FindFirstChild('Humanoid')

		if hum then
			--inflict damage
			TagHumanoid(hum)
			hum:TakeDamage(DamageToDo)
			Delay(0.1, function()
				UntagHumanoid(hum)
			end)
		end
		script.Parent.Parent = nil
	end
end)

local FlightTime = 2
for t = 0, FlightTime, 0.1 do
	wait(0.1)
	local fracLeft = (1-t/FlightTime)
	script.Parent.Size = Vector3.new(0.8, 0.8, 0.8)*fracLeft
	script.Parent.Mesh.Scale = Vector3.new(fracLeft, fracLeft, fracLeft)
	DamageToDo = 20*fracLeft
end

script.Parent.Parent = nil</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Part" referent="RBX301BB2B763FE419284C850FC5F3C241F">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize" />
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">4</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>57.4000015</Y>
							<Z>0</Z>
							<R00>0.961553633</R00>
							<R01>-0.274494171</R01>
							<R02>0.00826891419</R02>
							<R10>-0.00516340323</R10>
							<R11>0.0120347124</R11>
							<R12>0.999914169</R12>
							<R20>-0.274570346</R20>
							<R21>-0.96151334</R21>
							<R22>0.0101543553</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4291677645</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized" />
						<string name="Name">Handle</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">3</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>1</X>
							<Y>3</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
					<Item class="SpecialMesh" referent="RBXBAED457F908E46959A4B0726231F5498">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="MeshId"><url>http://www.roblox.com/asset/?id=66733632</url></Content>
							<token name="MeshType">5</token>
							<string name="Name">Mesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<Content name="TextureId"><url>http://www.roblox.com/asset/?id=66733800</url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="Camera" referent="RBX1D28BD2188F44B2594734EF79C0AC157">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<CoordinateFrame name="CFrame">
							<X>2.12940407</X>
							<Y>58.0444565</Y>
							<Z>-2.1260519</Z>
							<R00>-0.493938953</R00>
							<R01>-0.180762559</R01>
							<R02>0.850499392</R02>
							<R10>-0</R10>
							<R11>0.978151441</R11>
							<R12>0.207893372</R12>
							<R20>-0.869496524</R20>
							<R21>0.102686636</R21>
							<R22>-0.483147144</R22>
						</CoordinateFrame>
						<Ref name="CameraSubject">null</Ref>
						<token name="CameraType">0</token>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="FieldOfView">70</float>
						<token name="FieldOfViewMode">0</token>
						<CoordinateFrame name="Focus">
							<X>-4.13194752</X>
							<Y>56.5139503</Y>
							<Z>1.4308635</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="HeadLocked">true</bool>
						<float name="HeadScale">1</float>
						<string name="Name">ThumbnailCamera</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<bool name="VRTiltAndRollEnabled">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		