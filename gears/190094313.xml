<Item class="Model" referent="RBXA855EFC2582F4CDEB9A28D78E6C3E2B0">
			<Properties>
				<BinaryString name="AttributesSerialize" />
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">190094313</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags" />
				<OptionalCoordinateFrame name="WorldPivotData" />
			</Properties>
			<Item class="Tool" referent="RBX3A80AE440FDE4C8BA060EE8695233C76">
				<Properties>
					<BinaryString name="AttributesSerialize" />
					<bool name="CanBeDropped">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>1.5</X>
						<Y>3</Y>
						<Z>-0.850000024</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<token name="LevelOfDetail">0</token>
					<bool name="ManualActivationOnly">false</bool>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">RocketSkis</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<bool name="RequiresHandle">true</bool>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags" />
					<Content name="TextureId"><url>http://www.roblox.com/asset?id=189884124</url></Content>
					<string name="ToolTip" />
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-0.00358200073</X>
							<Y>17.3301048</Y>
							<Z>22.0126572</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBX73B9365EEFCD4587842C97446F6024D6">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize" />
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-0.00358200073</X>
							<Y>17.3301048</Y>
							<Z>22.0126572</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized" />
						<string name="Name">Handle</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>1.5</X>
							<Y>1.25</Y>
							<Z>5.75</Z>
						</Vector3>
					</Properties>
					<Item class="SpecialMesh" referent="RBXF71DCC9F8B5643418FECB1CA86235779">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="MeshId"><url>http://www.roblox.com/asset/?id=190096599 </url></Content>
							<token name="MeshType">5</token>
							<string name="Name">Mesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>1.25</X>
								<Y>1.5</Y>
								<Z>0.75</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<Content name="TextureId"><url>http://www.roblox.com/asset/?id=189884063 </url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX2342D716785E4616A1F1A079E4C19583">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">MouseIcon</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{A784AE9B-8B93-4166-A041-2827CBA77440}</string>
						<ProtectedString name="Source">--Made by Luckymaxer

Mouse_Icon = "rbxasset://textures/GunCursor.png"
Reloading_Icon = "rbxasset://textures/GunWaitCursor.png"

Tool = script.Parent

Mouse = nil

function UpdateIcon()
	if Mouse then
		Mouse.Icon = Tool.Enabled and Mouse_Icon or Reloading_Icon
	end
end

function OnEquipped(ToolMouse)
	Mouse = ToolMouse
	UpdateIcon()
end

function OnChanged(Property)
	if Property == "Enabled" then
		UpdateIcon()
	end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX8A375AEC03C34C4BA7AAA50BA8206CB9">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">LocalScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{E73C2D24-9698-4A07-9EEB-E9D30D3110EE}</string>
						<ProtectedString name="Source">--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
ContentProvider = game:GetService("ContentProvider")
RunService = game:GetService("RunService")

Camera = game:GetService("Workspace").CurrentCamera

Animations = {}
LocalObjects = {}

ServerControl = Tool:WaitForChild("ServerControl")
ClientControl = Tool:WaitForChild("ClientControl")

ToolEquipped = false

ClientControl.OnClientInvoke = (function(Mode, Value)
	if Mode == "PlayAnimation" and Value and ToolEquipped and Humanoid then
		SetAnimation("PlayAnimation", Value)
	elseif Mode == "StopAnimation" and Value then
		SetAnimation("StopAnimation", Value)
	elseif Mode == "Preload" and Value then
		ContentProvider:Preload(Value)
	elseif Mode == "PlaySound" and Value then
		Value:Play()
	elseif Mode == "StopSound" and Value then
		Value:Stop()
	elseif Mode == "MousePosition" then
		return PlayerMouse.Hit.p
	elseif Mode == "DisableJump" then
		DisableJump(Value)
	elseif Mode == "SetMouseIcon" and Value then
		PlayerMouse.Icon = Value
	elseif Mode == "SetLocalTransparencyModifier" and Value and ToolEquipped then
		pcall(function()
			local ObjectFound = false
			for i, v in pairs(LocalObjects) do
				if v == Value then
					ObjectFound = true
				end
			end
			if not ObjectFound then
				table.insert(LocalObjects, Value)
				if ObjectLocalTransparencyModifier then
					ObjectLocalTransparencyModifier:disconnect()
				end
				ObjectLocalTransparencyModifier = RunService.RenderStepped:connect(function()
					for i, v in pairs(LocalObjects) do
						if v.Object and v.Object.Parent then
							v.Object.LocalTransparencyModifier = v.Transparency
						end
					end
				end)
			end
		end)
	elseif Mode == "GetCamera" and Value then
		local PropertyValue = nil
		if Value.Property then
			pcall(function()
				PropertyValue = Camera[Value.Property]
			end)
		end
		return PropertyValue
	elseif Mode == "SetCamera" and Value then
		if Value.Property and Value.Value then
			pcall(function()
				Camera[Value.Property] = Value.Value
			end)
		end
	elseif Mode == "SetMouseSensitivity" and Value then
		if Value.Sensitivity == 1 then
			if MouseSensivityConnection then
				MouseSensivityConnection:disconnect()
			end
		else
			SetMouseSensitivity(Value.Sensitivity)
		end
	end
end)

function InvokeServer(Mode, Value)
	pcall(function()
		local ServerReturn = ServerControl:InvokeServer(Mode, Value)
		return ServerReturn
	end)
end

function SetAnimation(Mode, Value)
	if Mode == "PlayAnimation" and Value and ToolEquipped and Humanoid then
		for i, v in pairs(Animations) do
			if v.Animation == Value.Animation then
				v.AnimationTrack:Stop()
				table.remove(Animations, i)
			end
		end
		local AnimationTrack = Humanoid:LoadAnimation(Value.Animation)
		table.insert(Animations, {Animation = Value.Animation, AnimationTrack = AnimationTrack})
		AnimationTrack:Play(Value.FadeTime, Value.Weight, Value.Speed)
	elseif Mode == "StopAnimation" and Value then
		for i, v in pairs(Animations) do
			if v.Animation == Value.Animation then
				v.AnimationTrack:Stop()
				table.remove(Animations, i)
			end
		end
	end
end

function DisableJump(Boolean)
	if PreventJump then
		PreventJump:disconnect()
	end
	if Boolean then
		PreventJump = Humanoid.Changed:connect(function(Property)
			if Property ==  "Jump" then
				Humanoid.Jump = false
			end
		end)
	end
end

function SetMouseSensitivity(Sensitivity)

	if MouseSensivityConnection then
		MouseSensivityConnection:disconnect()
	end

	local function EulerAnglesYX(cframe)
		local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components(cframe)
		return -math.asin(R12), ((math.abs(R12) &gt; 0.99999 and -math.atan2(-R20, R00)) or -math.atan2(-R02, R22))
	end

	local DirectionX, DirectionY = EulerAnglesYX(Camera.CoordinateFrame)

	local function UpdateSensitivity()
		local CFrameX, CFrameY = EulerAnglesYX(Camera.CoordinateFrame)
		DirectionX = (DirectionX * (1 - Sensitivity) + (CFrameX + (math.pi * 2) * math.floor((DirectionX - CFrameX) / (math.pi * 2) + 0.5)) * Sensitivity)
		DirectionY = (DirectionY * (1 - Sensitivity) + (CFrameY + (math.pi * 2) * math.floor((DirectionY - CFrameY) / (math.pi * 2) + 0.5)) * Sensitivity)
		Camera.CoordinateFrame = CFrame.Angles(0, DirectionY, 0) * CFrame.Angles(DirectionX, 0, 0) * CFrame.new(0, 0, 0.5) + Camera.Focus.p
	end

	MouseSensivityConnection = RunService.RenderStepped:connect(UpdateSensitivity)

end

function CheckIfAlive()
	return (Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health &gt; 0)
end

function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	ToolEquipped = true
	if not CheckIfAlive() then
		return
	end
	PlayerMouse = Player:GetMouse()
	Mouse.Button1Down:connect(function()
		InvokeServer("MouseClick", {Down = true})
	end)
	Mouse.KeyDown:connect(function(Key)
		InvokeServer("KeyPress", {Key = Key, Down = true})
	end)
	Mouse.KeyUp:connect(function(Key)
		InvokeServer("KeyPress", {Key = Key, Down = false})
	end)
	Mouse.WheelForward:connect(function()
		InvokeServer("WheelMoved", {Forward = true})
	end)
	Mouse.WheelBackward:connect(function()
		InvokeServer("WheelMoved", {Forward = false})
	end)
end

function Unequipped()
	ToolEquipped = false
	LocalObjects = {}
	for i, v in pairs(Animations) do
		if v and v.AnimationTrack then
			v.AnimationTrack:Stop()
		end
	end
	for i, v in pairs({PreventJump, MouseSensivityConnection, ObjectLocalTransparencyModifier}) do
		if v then
			v:disconnect()
		end
	end
	PlayerMouse.Icon = ""
	Animations = {}
end

Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBX3B6762FDBF394D04A3CA193F2179967E">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">Script</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{113B718D-AB51-4465-8482-408A76AD0FED}</string>
						<ProtectedString name="Source">--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

NormalSurfaceModule = require(Tool:WaitForChild("NormalSurfaceModule"))

BasePart = Instance.new("Part")
BasePart.Shape = Enum.PartType.Block
BasePart.Material = Enum.Material.Plastic
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Size = Vector3.new(0.2, 0.2, 0.2)
BasePart.CanCollide = true
BasePart.Locked = true
BasePart.Anchored = false

SpeedBoostGui = Instance.new("ScreenGui")
SpeedBoostGui.Name = "SpeedBoostGui"
SpeedBoostFrame = Instance.new("Frame")
SpeedBoostFrame.Name = "Frame"
SpeedBoostFrame.BackgroundColor3 = Color3.new((255 / 255), (255 / 255), (255 / 255))
SpeedBoostFrame.BorderColor3 = Color3.new((0 / 255), (222 / 255), (222 / 255))
SpeedBoostFrame.BorderSizePixel = 2
SpeedBoostFrame.Position = UDim2.new(0.75, 0, 0.9, 0)
SpeedBoostFrame.Size = UDim2.new(0.2, 0, 0.075, 0)
SpeedBoostFrame.ZIndex = 1
SpeedBoostFrame.Parent = SpeedBoostGui
FuelDisplay = Instance.new("Frame")
FuelDisplay.Name = "FuelDisplay"
FuelDisplay.BackgroundColor3 = Color3.new((0 / 255), (255 / 255), (255 / 255))
FuelDisplay.BorderColor3 = Color3.new((0 / 255), (222 / 255), (222 / 255))
FuelDisplay.BorderSizePixel = 0
FuelDisplay.Position = UDim2.new(0, 0, 0)
FuelDisplay.Size = UDim2.new(1, 0, 1, 0)
FuelDisplay.ZIndex = 2
FuelDisplay.Parent = SpeedBoostFrame
HelpText = Instance.new("TextLabel")
HelpText.Name = "HelpText"
HelpText.BackgroundColor3 = Color3.new((255 / 255), (255 / 255), (255 / 255))
HelpText.BackgroundTransparency = 1
HelpText.BorderSizePixel = 0
HelpText.Position = UDim2.new(0, 0, 0, 0)
HelpText.Size = UDim2.new(1, 0, 0.35, 0)
HelpText.Font = Enum.Font.Legacy
HelpText.FontSize = Enum.FontSize.Size14
HelpText.Text = "(Hold Shift for boost)"
HelpText.TextColor3 = Color3.new((0 / 255), (0 / 255), (0 / 255))
HelpText.TextStrokeColor3 = Color3.new((0 / 255), (0 / 255), (0 / 255))
HelpText.TextStrokeTransparency = 0.95
HelpText.TextTransparency = 0.5
HelpText.TextScaled = true
HelpText.TextWrapped = true
HelpText.TextXAlignment = Enum.TextXAlignment.Center
HelpText.TextYAlignment = Enum.TextYAlignment.Center
HelpText.ZIndex = 3
HelpText.Parent = SpeedBoostFrame
TitleText = Instance.new("TextLabel")
TitleText.Name = "TitleText"
TitleText.BackgroundColor3 = Color3.new((255 / 255), (255 / 255), (255 / 255))
TitleText.BackgroundTransparency = 1
TitleText.BorderSizePixel = 0
TitleText.Position = UDim2.new(0, 0, 0.2, 0)
TitleText.Size = UDim2.new(1, 0, 0.8, 0)
TitleText.Font = Enum.Font.Arial
TitleText.FontSize = Enum.FontSize.Size14
TitleText.Text = "Rocket Boost"
TitleText.TextColor3 = Color3.new((0 / 255), (85 / 255), (255 / 255))
TitleText.TextStrokeColor3 = Color3.new((0 / 255), (0 / 255), (255 / 255))
TitleText.TextStrokeTransparency = 0.95
TitleText.TextTransparency = 0.5
TitleText.TextScaled = true
TitleText.TextWrapped = true
TitleText.TextXAlignment = Enum.TextXAlignment.Center
TitleText.TextYAlignment = Enum.TextYAlignment.Center
TitleText.ZIndex = 3
TitleText.Parent = SpeedBoostFrame

Animations = {
	IdleLegs = {Animation = Tool:WaitForChild("IdleLegs"), FadeTime = nil, Weight = nil, Speed = nil, Duration = nil},
	Swing = {Animation = Tool:WaitForChild("Swing"), FadeTime = nil, Weight = nil, Speed = nil, Duration = nil},
	Tuck = {Animation = Tool:WaitForChild("Tuck"), FadeTime = nil, Weight = nil, Speed = nil, Duration = nil} --http://www.roblox.com/asset/?id=190071033
}

Sounds = {
}

SpeedBoost = {
	MaxFuel = 100,
	CurrentFuel = 100,
	IncreaseRate = 0.25,
	DecreaseRate = 0.5,
	UsageRate = (1 / 30),
	Regenerating = false,
	Active = false
}

LastUpdate = nil
State = "Stopped"
LastStateTime = 0

ToolEquipped = false
SkiActive = false

DisplayModel = Tool:FindFirstChild("DisplayModel")
if DisplayModel then
	DisplayModel:Destroy()
end

for i, v in pairs(Tool:GetChildren()) do
	if (v:IsA("BasePart") and v ~= Handle) then
		v:Destroy()
	end
end

ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool

ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool

Handle.Transparency = 0
Tool.Enabled = true

ServerControl.OnServerInvoke = (function(player, Mode, Value)
	if player == Player then
		if Mode == "MouseClick" and Value.Down then
			Activated()
		elseif Mode == "KeyPress" then
			local Key = Value.Key
			local ByteKey = string.byte(Key)
			local Down = Value.Down
			if ByteKey == 48 and SkiActive and ToolEquipped then
				if Down and not SpeedBoost.Active and SpeedBoost.CurrentFuel &gt; (SpeedBoost.MaxFuel / 2) then
					SpeedBoost.Active = true
					SetSpeedBoost(true)
					while ToolEquipped and SpeedBoost.Active and SpeedBoost.CurrentFuel &gt; 0 do
						SpeedBoost.CurrentFuel = (SpeedBoost.CurrentFuel - SpeedBoost.DecreaseRate)
						FuelDisplay.Size = UDim2.new((1 / (SpeedBoost.MaxFuel / SpeedBoost.CurrentFuel)), 0, 1, 0)
						wait(SpeedBoost.Rate)
					end
					SpeedBoost.Active = false
					SpeedBoost.CurrentFuel = ((SpeedBoost.CurrentFuel &lt; 0 and 0) or SpeedBoost.CurrentFuel)
					SetSpeedBoost(false)
					RegenerateFuel()
				else
					SpeedBoost.Active = false
					SetSpeedBoost(false)
				end
			end
		end
	end
end)

function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end

function RayCast1(Position, Direction, MaxDistance, IgnoreList)
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(Position, Direction.unit * (MaxDistance or 999.999)), IgnoreList)
end

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function SetSpeedBoost(Boolean)
	for i, v in pairs({LeftSki, RightSki}) do
		local RocketPart = v:FindFirstChild("RocketPart")
		if RocketPart then
			local Weld = RocketPart:FindFirstChild("Weld")
			if Weld and Weld.Part0 == v and Weld.Part1 == RocketPart then
				for ii, vv in pairs(RocketPart:GetChildren()) do
					if vv:IsA("Fire") then
						vv.Enabled = Boolean
					end
				end
			end
		end
	end
end

function RegenerateFuel()
	Spawn(function()
		if SpeedBoost.Regenerating then
			return
		end
		while --[[ToolEquipped and]] not SpeedBoost.Active and SpeedBoost.CurrentFuel &lt; SpeedBoost.MaxFuel do
			SpeedBoost.Regenerating = true
			SpeedBoost.CurrentFuel = (SpeedBoost.CurrentFuel + SpeedBoost.IncreaseRate)
			FuelDisplay.Size = UDim2.new((1 / (SpeedBoost.MaxFuel / SpeedBoost.CurrentFuel)), 0, 1, 0)
			wait(SpeedBoost.UsageRate)
		end
		SpeedBoost.Regenerating = false
		SpeedBoost.CurrentFuel = ((SpeedBoost.CurrentFuel &gt; SpeedBoost.MaxFuel and SpeedBoost.MaxFuel) or SpeedBoost.CurrentFuel)
	end)
end

function StopSkis()
	if FunctionSkis then
		FunctionSkis:disconnect()
	end
	LastUpdate = nil
	LastStateTime = 0
	State = "Stopped"
	if BodyVelocity and BodyVelocity.Parent then
		BodyVelocity.velocity = Vector3.new(0, 0, 0)
		BodyVelocity.maxForce = Vector3.new(0, 0, 0)
	end
end

function Activated()
	if not Tool.Enabled or not ToolEquipped then
		return
	end
	if SkiActive then
		for i, v in pairs(Animations) do
			InvokeClient("StopAnimation", v)
		end
		StopSkis()
	else
		InvokeClient("PlayAnimation",Animations.IdleLegs)
		FunctionSkis = RunService.Heartbeat:connect(function()
			BodyVelocity.maxForce = Vector3.new(math.huge, 0, math.huge)
			UpdateSkiVelocity()
		end)
	end
	SkiActive = not SkiActive
end

function GetNormal(part, point)
	local Normal = NormalSurfaceModule(part, point)
	return ((part.CFrame-part.CFrame.p) * Normal)
end

function AngleFromFlat(Vec1)
	local Vec1 = Vec1.unit
	local FlatVec = (Vec1 * Vector3.new(1, 0, 1)).unit
	local Angle = math.acos(Vec1:Dot(FlatVec))
	if Angle ~= Angle then --If the angle is nan then assume flat surface
		return math.rad(90)
	end
	return (math.rad(90) - Angle)
end

function RayIgnoreCheck(Hit, Pos)
	return false
end

function RayIgnoreCamera(Hit, Pos)
	if Hit then
		if not Hit.CanCollide then
			return true
		end
	end
	return false
end

function RayCast2(StartPos, Vec, RayLength, IgnoreFunc, IgnoreList) -- @preconditions: Vec should be a unit Vector, and 0 &lt; RayLength &lt;= 1000
	IgnoreFunc = (IgnoreFunc or RayIgnoreCheck)
	IgnoreList = (IgnoreList or {Character})
	Vec = Vec.unit
	local Ray = Ray.new(StartPos, (Vec * RayLength))
	local HitObject, HitPos = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray, IgnoreList)
	if HitObject and HitPos then
		if IgnoreFunc(HitObject, HitPos) then
			table.insert(IgnoreList, HitObject)
			return RayCast2(StartPos, Vec, RayLength, IgnoreFunc, IgnoreList)
		end
	end
	return HitObject, HitPos
end

function GetGroundBelowCharacter()
	if Torso then
		local TorsoCFrame = Torso.CFrame
		local HitData = {}
		for z = -1, 1, 2 do
			for x = -1, 1, 2 do
				local RayPos = (TorsoCFrame.p + TorsoCFrame:vectorToWorldSpace(Vector3.new(((Torso.Size.X / 2) * x), 0, ((Torso.Size.Z / 2) * z))))
				local Hit, Pos = RayCast2(RayPos, Vector3.new(0, -1, 0), ((Torso.Size.Y / 2) + Torso.Size.Y + 6), RayIgnoreCamera)
				if Hit and Pos then
					table.insert(HitData, {["Pos"] = CFrame.new(Vector3.new(TorsoCFrame.p.X, (Pos.Y + 3), TorsoCFrame.p.Z)), ["Part"] = Hit})
				end
			end
		end
		table.sort(HitData, (function(a, b)
			return a["Pos"].p.Y &gt; b["Pos"].p.Y
		end))
		if #HitData &gt; 0 then
			return HitData[1]["Pos"], HitData[1]["Part"]
		end
		return TorsoCFrame, nil
	end
end

function StudsPerSToMetersPerS(studs)
	return (studs / 2)
end

function MetersPerSToStudsPerS(meters)
	return (meters * 2.5)
end

function UpdateSkiVelocity()
	if not ToolEquipped or not CheckIfAlive() then
		return
	end
	local Now = tick()
	if not LastUpdate then
		LastUpdate = Now
		return
	end
	local GroundHit, GroundPart = GetGroundBelowCharacter(Character)
	if GroundHit and GroundPart then
		local Normal = GetNormal(GroundPart, GroundHit.p)
		local Theta = AngleFromFlat(Normal) --[[ Angle of slope --]]
		local DeltaTime = (Now - LastUpdate)
		if BodyVelocity.velocity.magnitude &lt; 22 then
			if State ~= "Poles" and (tick() - LastStateTime) &gt; 0.5 then
				InvokeClient("StopAnimation", Animations.Tuck)
				InvokeClient("PlayAnimation", Animations.Swing)
				State = "Poles"
				LastStateTime = Now
			end
			local SkiOrientation = (Torso.CFrame.lookVector * Vector3.new(1,0,1)).unit
			if math.abs(math.acos(SkiOrientation:Dot(BodyVelocity.velocity.unit))) &gt; (math.pi / 3) then
				BodyVelocity.velocity = (BodyVelocity.velocity * (1 - 0.55 * DeltaTime))
			end
			BodyVelocity.velocity = (BodyVelocity.velocity + (SkiOrientation * 19 * DeltaTime))
		else
			if State ~= "Tuck" and (tick() - LastStateTime) &gt; 0.5 and (State ~= "Poles" or BodyVelocity.velocity.magnitude &gt; 24) then
				InvokeClient("StopAnimation", Animations.Swing)
				InvokeClient("PlayAnimation", Animations.Tuck)
				State = "Tuck"
				LastStateTime = Now
			end

			local KineticSkiSnow = 0.05 --dynamic coeff of snow
			local CdAp = 0.65 --Drag coeff with frontal area
			local rho = 1.3413 --kg*m^3
			local Velocity = StudsPerSToMetersPerS(Torso.Velocity).magnitude
			local Mass = 65
			local Gravity = 9.81
			Gravity = ((SpeedBoost.Active and (Gravity * 2.5)) or Gravity)

			local DownhillVec = Vector3.new(0,1,0):Cross(Normal):Cross(Normal)

			local SkiOrientation = (Torso.CFrame.lookVector * Vector3.new(1, 0, 1)).unit
			local AngleBetweenLookAndHill = math.acos((DownhillVec * Vector3.new(1, 0, 1)).unit:Dot(SkiOrientation))
			if math.abs(AngleBetweenLookAndHill) &gt; math.rad(90) then -- if we are pointed uphill, flip direction
				SkiOrientation = (SkiOrientation * -1)
				AngleBetweenLookAndHill = math.acos((DownhillVec * Vector3.new(1, 0, 1)).unit:Dot(SkiOrientation))
			end
			local Acceleration = (Gravity * math.sin(Theta) - KineticSkiSnow * Gravity * math.cos(Theta) - (CdAp * rho * (Velocity ^ 2)) / (2 * Mass))
			if math.abs(math.acos(SkiOrientation:Dot(BodyVelocity.velocity.unit))) &gt; (math.pi / 3) then
				BodyVelocity.velocity = (BodyVelocity.velocity * (1 - 0.55 * DeltaTime))
			end
			BodyVelocity.velocity = (BodyVelocity.velocity + ((SkiOrientation + Vector3.new(0, 0.0001, 0)).unit * Acceleration) * DeltaTime)

			LastUpdate = Now

		end

	end
end

function EquipSkis()
	if not CheckIfAlive() then
		return
	end
	BodyGyro = Instance.new("BodyGyro")
	BodyGyro.cframe = Torso.CFrame
	BodyGyro.maxTorque = Vector3.new(math.huge, math.huge, math.huge)
	BodyGyro.Parent = Torso
	BodyVelocity = Instance.new("BodyVelocity")
	BodyVelocity.maxForce = Vector3.new(0, 0, 0)
	BodyVelocity.velocity = Vector3.new(0, 0, 0)
	BodyVelocity.Parent = Torso
	local Ski = BasePart:Clone()
	Ski.Name = "Ski"
	Ski.Transparency = 0
	Ski.Size = Vector3.new(0.5, 1.15, 5.75)
	Ski.CanCollide = false
	Ski.Velocity = Vector3.new(0, 0, 0)
	Ski.RotVelocity = Vector3.new(0, 0, 0)
	RocketPart = BasePart:Clone()
	RocketPart.Name = "RocketPart"
	RocketPart.Transparency = 1
	RocketPart.Size = Vector3.new(0.5, 1, 0.85)
	RocketPart.CanCollide = false
	local Fire = Instance.new("Fire")
	Fire.Color = Color3.new((236 / 255), (139 / 255), (70 / 255))
	Fire.SecondaryColor = Color3.new((139 / 255), (80 / 255), (55 / 255))
	Fire.Heat = 10
	Fire.Size = 5
	Fire.Enabled = false
	Fire.Parent = RocketPart
	local RocketWeld = Instance.new("Weld")
	RocketWeld.Part0 = Ski
	RocketWeld.Part1 = RocketPart
	RocketWeld.C0 = CFrame.new(0, 0, 0)
	RocketWeld.C1 = CFrame.new(0, -3, 0) * CFrame.Angles(-(math.pi / 2), 0, 0)
	RocketWeld.Parent = RocketPart
	RocketPart.Parent = Ski
	local Mesh = Instance.new("SpecialMesh")
	Mesh.TextureId = "http://www.roblox.com/asset?id=189884063"
	Mesh.MeshType = Enum.MeshType.FileMesh
	Mesh.Offset = Vector3.new(0, 0.35, 0)
	Mesh.Scale = Vector3.new(1.25, 1.5, 0.75)
	Mesh.Parent = Ski
	local LeftLeg = Character:FindFirstChild("Left Leg")
	local RightLeg = Character:FindFirstChild("Right Leg")
	if LeftLeg then
		LeftSki = Ski:Clone()
		LeftSki.Name = "LeftSki"
		LeftSki.Mesh.MeshId = "http://www.roblox.com/asset?id=189884041"
		LeftWeld = Instance.new("Weld")
		LeftWeld.Part0 = LeftLeg
		LeftWeld.Part1 = LeftSki
		LeftWeld.C0 = CFrame.new(0, 0, 0)
		LeftWeld.C1 = CFrame.new(0, 0.55, 0.675)
		LeftWeld.Parent = LeftSki
		LeftSki.Parent = Tool
		InvokeClient("SetLocalTransparencyModifier", {Object = LeftLeg, Transparency = 0})
	end
	if RightLeg then
		RightSki = Ski:Clone()
		RightSki.Name = "RightSki"
		RightSki.Mesh.MeshId = "http://www.roblox.com/asset?id=189884023"
		RightWeld = Instance.new("Weld")
		RightWeld.Part0 = RightLeg
		RightWeld.Part1 = RightSki
		RightWeld.C0 = CFrame.new(0, 0, 0)
		RightWeld.C1 = CFrame.new(0, 0.55, 0.675)
		RightWeld.Parent = RightSki
		RightSki.Parent = Tool
		InvokeClient("SetLocalTransparencyModifier", {Object = RightLeg, Transparency = 0})
	end
	if SkiAlign then
		SkiAlign:disconnect()
	end
	SkiAlign = RunService.Heartbeat:connect(function()
		if (not (LeftLeg and LeftLeg.Parent and LeftSki and LeftSki.Parent and LeftWeld and LeftWeld.Parent) or not (RightLeg and RightLeg.Parent and RightSki and RightSki.Parent and RightWeld and RightWeld.Parent)) then
			SkiAlign:disconnect()
			return
		end
		local RayHit, RayPos = RayCast1(Torso.Position, Vector3.new(0, -1, 0), (Torso.Size * 2), {Character})
		if RayHit then
			local Normal = NormalSurfaceModule(RayHit, RayPos)
			local StickCFrame = CFrame.new(RayPos, (RayPos + Normal)) * CFrame.Angles((math.pi / 2), 0, 0)
			BodyGyro.maxTorque = Vector3.new(math.huge, 0, math.huge)
			BodyGyro.cframe = StickCFrame * CFrame.Angles(math.pi, 0, 0)
		else
--			BodyGyro.maxTorque = Vector3.new(0, 0, 0)
		end
	end)
end

function CheckIfAlive()
	return (Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health &gt; 0)
end

function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	PlayerGui = Player:FindFirstChild("PlayerGui")
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso")
	if not CheckIfAlive() then
		return
	end
	if PlayerGui then
		SpeedBoostGuiClone = SpeedBoostGui:Clone()
		FuelDisplay = SpeedBoostGuiClone.Frame.FuelDisplay
		FuelDisplay.Size = UDim2.new((1 / (SpeedBoost.MaxFuel / SpeedBoost.CurrentFuel)), 0, 1, 0)
		SpeedBoostGuiClone.Parent = PlayerGui
	end
	RegenerateFuel()
	for i, v in pairs(Tool:GetChildren()) do
		if (v:IsA("BasePart") and v ~= Handle) then
			v:Destroy()
		end
	end
	for i, v in pairs(Animations) do
		if v and v.Animation then
			InvokeClient("Preload", v.Animation.AnimationId)
		end
	end
	Handle.Transparency = 1
	Spawn(function()
		EquipSkis()
	end)
	ToolEquipped = true
end

function Unequipped()
	StopSkis()
	SkiActive = false
	for i, v in pairs({LeftSki, RightSki, BodyGyro, BodyVelocity, SpeedBoostGuiClone}) do
		if v and v.Parent then
			v:Destroy()
		end
	end
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			v:Destroy()
		end
	end
	for i, v in pairs({SkiAlign, FunctionSkis}) do
		if v then
			v:disconnect()
		end
	end
	if CheckIfAlive() then
		local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = Torso.CFrame:components()
		Torso.CFrame = CFrame.new(X, Y, Z, R00, 0, R02, 0, R11, R12, R20, 0, R22)
	end
	Handle.Transparency = 0
	for i, v in pairs(Animations) do
		InvokeClient("StopAnimation", v)
	end
	ToolEquipped = false
end

Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6AF919CCF10745DC980B1B4A448BBBD7">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">NormalSurfaceModule</string>
						<string name="ScriptGuid">{03C9A382-8DEC-487A-91AD-83ABA4176474}</string>
						<ProtectedString name="Source">--Normal Surface Retrieval by xXxMoNkEyMaNxXx

Terrain = game:GetService("Workspace").Terrain
GetCell = Terrain.GetCell
CellCenterToWorld = Terrain.CellCenterToWorld
WorldToCellPreferSolid = Terrain.WorldToCellPreferSolid

IdentityVector = Vector3.new()
IdentityCFrame = CFrame.new()

--Returns:
--Index of closest plane to p
--Distance to surface from p
function ClosestNormalVector(p, planes)
	local best_d = -math.huge
	local best_i
	for i = 1, #planes do
		local plane = planes[i]
		local d = IdentityVector.Dot(plane[1], (p - plane[2]))
		if d &gt; best_d then
			best_i, best_d = i, d
		end
	end
	return best_i, best_d
end

--Part geometry data
UnitaryConvexPlaneMeshes = { --Each component of the normal vector dependent on every component of the size using matrices
	WedgePart = {{Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(0, 0, 1), Vector3.new(0, 0, 0.5)}, {CFrame.new(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0), Vector3.new(0, 0, 0)}, {Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(-1, 0, 0), Vector3.new(-0.5, 0, 0)}},
	CornerWedgePart = {{Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(0, 0, -1), Vector3.new(0, 0, -0.5)}, {CFrame.new(0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0), Vector3.new(0, 0, 0)}, {CFrame.new(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0), Vector3.new(0, 0, 0)}},
	Part = {{Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(0, 1, 0), Vector3.new(0, 0.5, 0)}, {Vector3.new(0, 0, 1), Vector3.new(0, 0, 0.5)}, {Vector3.new(-1, 0, 0), Vector3.new(-0.5, 0, 0)}, {Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(0, 0, -1), Vector3.new(0, 0, -0.5)}}
}

--Terrain geometry data
TerrainCellSize = Vector3.new(4, 4, 4) --Arbitrary size input
TerrainCellOrientations = {
	[0] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
	CFrame.new(0, 0, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
	CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),
	CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
}
TerrainCellBlockUnitaryConvexPlaneMeshes = {
	[0] = {{Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(0, 1, 0), Vector3.new(0, 0.5, 0)}, {Vector3.new(0, 0, 1), Vector3.new(0, 0, 0.5)}, {Vector3.new(-1, 0, 0), Vector3.new(-0.5, 0, 0)}, {Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(0, 0, -1), Vector3.new(0, 0, -0.5)}},
	{{Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(-1, 0, 0), Vector3.new(-0.5, 0, 0)}, {Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(0, 0, -1), Vector3.new(0, 0, -0.5)}, {CFrame.new(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0), Vector3.new(0, 0, 0)}},
	{{Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(0, 0, -1), Vector3.new(0, 0, -0.5)}, {CFrame.new(0, 0, 0, 0, -1, -1, 1, 0, 1, 1, 1, 0), Vector3.new(0.5, -0.5, -0.5)/3}},
	{{Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(0, 1, 0), Vector3.new(0, 0.5, 0)}, {Vector3.new(0, 0, 1), Vector3.new(0, 0, 0.5)}, {Vector3.new(-1, 0, 0), Vector3.new(-0.5, 0, 0)}, {Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(0, 0, -1), Vector3.new(0, 0, -0.5)}, {CFrame.new(0, 0, 0, 0, -1, -1, 1, 0, 1, 1, 1, 0), Vector3.new(-0.5, 0.5, 0.5)/3}},
	{{Vector3.new(1, 0, 0), Vector3.new(0.5, 0, 0)}, {Vector3.new(0, 1, 0), Vector3.new(0, 0.5, 0)}, {Vector3.new(0, -1, 0), Vector3.new(0, -0.5, 0)}, {Vector3.new(0, 0, -1), Vector3.new(0, 0, -0.5)}, {CFrame.new(0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0), Vector3.new(0, 0, 0)}}
}

function NormalVector(part, point)
	if part.ClassName == "Part" and (part.Shape == Enum.PartType.Ball or part.Shape == Enum.PartType.Cylinder) then
		return IdentityCFrame.vectorToWorldSpace(part.CFrame, IdentityCFrame.pointToObjectSpace(part.CFrame, point).unit)
	else
		local partCFrame, partSize = part.CFrame, part.Size
		local UCPM
		if part.ClassName == "Terrain" then
			local CellGridLocation = WorldToCellPreferSolid(part, Vector3.new(point.x, (point.y - 1e-5), point.z))--Ugly floating point fix
			local CellMaterial, CellBlock, CellOrientation = GetCell(part, CellGridLocation.x, CellGridLocation.y, CellGridLocation.z)
			partCFrame = (TerrainCellOrientations[CellOrientation.Value] + CellCenterToWorld(part, CellGridLocation.x, CellGridLocation.y, CellGridLocation.z))
			partSize = TerrainCellSize
			UCPM = TerrainCellBlockUnitaryConvexPlaneMeshes[CellBlock.Value]
		else
			UCPM = UnitaryConvexPlaneMeshes[part.ClassName] or UnitaryConvexPlaneMeshes.Part --Trusses, SpawnLocations, etc.
		end
		local CPM = {}
		for i = 1, #UCPM do
			local plane = UCPM[i]
			CPM[i] = {(plane[1] * partSize).unit, plane[2] * partSize}
		end
		local PlaneIndex, DistanceToSurface = ClosestNormalVector(IdentityCFrame.pointToObjectSpace(partCFrame, point), CPM)
		if PlaneIndex then
			return IdentityCFrame.vectorToWorldSpace(partCFrame, CPM[PlaneIndex][1])
		else
			return IdentityVector --Dead code unless the tables are tampered with
		end
	end
end

return NormalVector</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Animation" referent="RBX4A935E1901D84089B019AEB7E868834B">
					<Properties>
						<Content name="AnimationId"><url>http://www.roblox.com/asset?id=190032723</url></Content>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">IdleLegs</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Animation" referent="RBXC2081FE0DC63403A85236804E303A680">
					<Properties>
						<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=190070830</url></Content>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Swing</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Animation" referent="RBX336A78750DEE45D7B6E56FFECB3084A1">
					<Properties>
						<Content name="AnimationId"><null /></Content>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tuck</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Camera" referent="RBX931B7CDA47AC46F3AC279AE9D8094F6B">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<CoordinateFrame name="CFrame">
							<X>-0.498961329</X>
							<Y>21.9091167</Y>
							<Z>20.7450905</Z>
							<R00>-0.958950043</R00>
							<R01>0.274293959</R01>
							<R02>-0.0719554201</R02>
							<R10>-0</R10>
							<R11>0.253743887</R11>
							<R12>0.967271447</R12>
							<R20>0.283574969</R20>
							<R21>0.927564979</R21>
							<R22>-0.243327737</R22>
						</CoordinateFrame>
						<Ref name="CameraSubject">null</Ref>
						<token name="CameraType">0</token>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="FieldOfView">70</float>
						<token name="FieldOfViewMode">0</token>
						<CoordinateFrame name="Focus">
							<X>-0.39822337</X>
							<Y>20.5549316</Y>
							<Z>21.0857506</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="HeadLocked">true</bool>
						<float name="HeadScale">1</float>
						<string name="Name">ThumbnailCamera</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<bool name="VRTiltAndRollEnabled">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		