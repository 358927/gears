<Item class="Model" referent="RBX89EFAB2461884AF3AE72A582C3EE07A0">
			<Properties>
				<BinaryString name="AttributesSerialize" />
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">73232786</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">null</Ref>
				<float name="ScaleFactor">1</float>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags" />
				<OptionalCoordinateFrame name="WorldPivotData" />
			</Properties>
			<Item class="Tool" referent="RBX86FF80F7EFD74E6F922DFEBC366DB7E8">
				<Properties>
					<BinaryString name="AttributesSerialize" />
					<bool name="CanBeDropped">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Enabled">true</bool>
					<CoordinateFrame name="Grip">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>-4.37113883e-08</R11>
						<R12>1</R12>
						<R20>0</R20>
						<R21>-1</R21>
						<R22>-4.37113883e-08</R22>
					</CoordinateFrame>
					<token name="LevelOfDetail">0</token>
					<bool name="ManualActivationOnly">false</bool>
					<CoordinateFrame name="ModelMeshCFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
					<Vector3 name="ModelMeshSize">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="ModelStreamingMode">0</token>
					<string name="Name">DragonBoStaff</string>
					<bool name="NeedsPivotMigration">false</bool>
					<Ref name="PrimaryPart">null</Ref>
					<bool name="RequiresHandle">true</bool>
					<float name="ScaleFactor">1</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags" />
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=73184333</url></Content>
					<string name="ToolTip" />
					<OptionalCoordinateFrame name="WorldPivotData">
						<CFrame>
							<X>-3.211766</X>
							<Y>30.2512493</Y>
							<Z>31.2924519</Z>
							<R00>0.0656360537</R00>
							<R01>-0.993111014</R01>
							<R02>0.0970673859</R02>
							<R10>-0.688549936</R10>
							<R11>0.0253296811</R11>
							<R12>0.72474581</R12>
							<R20>-0.722212255</R20>
							<R21>-0.114405304</R21>
							<R22>-0.682144105</R22>
						</CFrame>
					</OptionalCoordinateFrame>
				</Properties>
				<Item class="Part" referent="RBX971E3E846C3E43D2993A6FCD9A5ACF39">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize" />
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-3.211766</X>
							<Y>30.2512493</Y>
							<Z>31.2924519</Z>
							<R00>0.0656360537</R00>
							<R01>-0.993111014</R01>
							<R02>0.0970673859</R02>
							<R10>-0.688549936</R10>
							<R11>0.0253296811</R11>
							<R12>0.72474581</R12>
							<R20>-0.722212255</R20>
							<R21>-0.114405304</R21>
							<R22>-0.682144105</R22>
						</CoordinateFrame>
						<bool name="CanCollide">true</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">true</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized" />
						<string name="Name">Handle</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">0</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">3</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>0.5</X>
							<Y>0.5</Y>
							<Z>7</Z>
						</Vector3>
					</Properties>
					<Item class="SpecialMesh" referent="RBX2E5093903B764821A6C14965F72F51D0">
						<Properties>
							<BinaryString name="AttributesSerialize" />
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="MeshId"><url>http://www.roblox.com/asset/?id=72008503</url></Content>
							<token name="MeshType">5</token>
							<string name="Name">Mesh</string>
							<Vector3 name="Offset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="Scale">
								<X>1.75</X>
								<Y>1.75</Y>
								<Z>1.75</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags" />
							<Content name="TextureId"><url>http://www.roblox.com/asset/?id=72008530</url></Content>
							<Vector3 name="VertexColor">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX4E965E032D764858BAFAC280046F9926">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">MainClient</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{33D0266D-EAEA-4849-A78A-4A4DAED4C9DC}</string>
						<ProtectedString name="Source">script.Parent.Equipped:connect(function(mouse)
	mouse.Button1Down:connect(function()
		script.Parent.Remote:FireServer('MB1Down')
	end)
	mouse.Button1Up:connect(function()
		script.Parent.Remote:FireServer('MB1Up')
	end)
end)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBX2335D070773143F7941048004B01AAB1">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">Damage</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{CE89E1DF-5681-4BA6-8AFB-6B6C13228452}</string>
						<ProtectedString name="Source">local function class(name)
	local def = {}
	getfenv(0)[name] = def
	return function(ctor, static)
		local nctor = function(...)
			local this = {}
			if ctor then
				ctor(this, ...)
			end
			return this
		end
		getfenv(0)['Create'..name] = nctor
		if static then static(def) end
	end
end

local function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

class'Signal'(function(this)
	local mListeners = {}
	local mWaitObject = Create'BoolValue'{}

	function this:connect(func)
		local connection = {}
		function connection:disconnect()
			mListeners[func] = nil
		end
		mListeners[func] = connection
		return connection
	end

	function this:fire(...)
		for func, conn in pairs(mListeners) do
			func(...)
		end
		mWaitObject.Value = not mWaitObject.Value
	end

	function this:wait()
		mWaitObject.Changed:wait()
	end
end)

--[[
	DamageReducer
		Reduces damage taken to humanoid by a specified percentage.

	CreateDamageReducer()
		Returns a new DamageReducer.
	DamageReducer:SetHumanoid(humanoid)
		Sets the humanoid. `humanoid` can be nil.
	DamageReducer:SetActive(active)
		Sets whether the damage reducer is active.
	DamageReducer:SetReduction(pct)
		Sets the amount of damage reduction as a percentage.
]]
class'DamageReducer'(function(def)
	local reduction = 0
	local active = false
	local humanoid
	local changed

	local function connect_changed()
		if not changed then
			local e = true
			local last_health = humanoid.Health
			changed = humanoid.HealthChanged:connect(function(health)
				if e then
					e = false
					if health &lt; last_health then
						local damage = math.abs(health - last_health)
						humanoid.Health = health + damage*reduction
					end
					e = true
				end
				last_health = humanoid.Health
			end)
		end
	end

	local function disconnect_changed()
		if changed then
			changed:disconnect()
			changed = nil
		end
	end

	function def:SetHumanoid(h)
		if changed then
			disconnect_changed()
		end
		humanoid = h
		if h and active then
			connect_changed()
		end
	end

	function def:SetReduction(pct)
		reduction = pct &lt; 0 and 0 or pct &gt; 1 and 1 or pct
	end

	function def:SetActive(a)
		active = a
		if a then
			connect_changed()
		else
			disconnect_changed()
		end
	end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- Tiny Event Manager; Add: [[Event.EventName = (event)]]; Remove: [[Disconnect("EventName",...)]]
local Event = {}
local function Disconnect(...)
	for _,name in pairs{...} do
		if Event[name] then
			Event[name]:disconnect()
			Event[name] = nil
		end
	end
end

-- get an object; make it if it doesn't exist
local function GetMake(parent,name,type)
	local object = parent:FindFirstChild(name)
	if not object then
		object = Create(type){Name=name}
		object.Parent = parent
	end
	return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
	while not parent:FindFirstChild(name) do
		parent.ChildAdded:wait()
	end
	return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
	if object and object.Parent then
		for i,v in pairs(object.Parent:GetChildren()) do
			if v:IsA"Humanoid" then
				return v
			end
		end
	end
	return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
	local humanoid = GetHumanoid(object)
	if humanoid then
		return object.Parent,humanoid
	end
	return nil
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Players = Game:GetService("Players")
local Debris = Game:GetService("Debris")

local Tool = script.Parent
local Handle = WaitForChild(Tool,"Handle")
local BurnScript = Tool:FindFirstChild("BurnScript")
local DamageBin = WaitForChild(Tool,"DamageBin")
local Spinning = WaitForChild(Tool,"Spinning")

local DamageReducer = CreateDamageReducer()
DamageReducer:SetReduction(0.25)

Spinning.Changed:connect(function(value)
	DamageReducer:SetActive(value)
end)

Tool.Equipped:connect(function()
	local Character,Humanoid = GetCharacter(Tool)
	local Player = Players:GetPlayerFromCharacter(Character)

	if BurnScript then
		local ctag = GetMake(BurnScript,"creator","ObjectValue")
		ctag.Value = Player
	end

	DamageReducer:SetHumanoid(Humanoid)

	Event.DamageBin = DamageBin.ChildAdded:connect(function(dtag)
		if dtag:IsA"ObjectValue" then
			local humanoid = dtag.Value
			local damage = tonumber(dtag.Name)
			if humanoid and damage then
				local ctag = Create'ObjectValue'{
					Name = "creator";
					Value = Player;
				}
				ctag.Parent = humanoid
				humanoid:TakeDamage(damage)
				Debris:AddItem(ctag,1)
				Debris:AddItem(dtag,1)
			end
		end
	end)
end)

Tool.Unequipped:connect(function()
	DamageReducer:SetHumanoid()
	Disconnect("DamageBin")
end)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBXEC99A52C34E744ACAA46E777F09400CD">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">BurnScript</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{A52193D6-6119-4C90-A1C8-0BA1BBB20BF5}</string>
						<ProtectedString name="Source">local damage = 2
local interval = 0.5

local Debris = Game:GetService("Debris")
local BodyPart = script.Parent
local Humanoid
do
	if BodyPart.Parent then
		for i,v in pairs(BodyPart.Parent:GetChildren()) do
			if v:IsA"Humanoid" then
				Humanoid = v
				break
			end
		end
	end
end

if Humanoid then
	local Fire = Instance.new("Fire",BodyPart)
	Fire.Color = Color3.new(246/255,69/255,0)
	Fire.SecondaryColor = Color3.new(102/255,0,102/255)
	script.Parent = Fire

	local died = false
	Humanoid.Died:connect(function() died = true end)

	local CreatorTag = script:FindFirstChild("creator")
	if CreatorTag then
		CreatorTag = CreatorTag:Clone()
		while not died do
			local ctag = CreatorTag:Clone()
			ctag.Parent = Humanoid
			Humanoid:TakeDamage(damage)
			Debris:AddItem(ctag,interval)
			wait(interval)
		end
	else
		while not died do
			Humanoid:TakeDamage(damage)
			wait(interval)
		end
	end
end
script:Destroy()</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Script" referent="RBX201483BA1C8B43E1A12C75F04C5AA35D">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null /></Content>
						<string name="Name">MainServer</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{F9D61788-D3D8-4861-8439-9738D2080FBD}</string>
						<ProtectedString name="Source">local function class(name)
	local def = {}
	getfenv(0)[name] = def
	return function(ctor, static)
		local nctor = function(...)
			local this = {}
			if ctor then
				ctor(this, ...)
			end
			return this
		end
		getfenv(0)['Create'..name] = nctor
		if static then static(def) end
	end
end

local function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

class'Signal'(function(this)
	local mListeners = {}
	local mWaitObject = Create'BoolValue'{}

	function this:connect(func)
		local connection = {}
		function connection:disconnect()
			mListeners[func] = nil
		end
		mListeners[func] = connection
		return connection
	end

	function this:fire(...)
		for func, conn in pairs(mListeners) do
			func(...)
		end
		mWaitObject.Value = not mWaitObject.Value
	end

	function this:wait()
		mWaitObject.Changed:wait()
	end
end)

--[[
KeyframeCatcher
	Detects when an AnimationTrack reaches a keyframe, then invokes a specified function corresponding to the keyframe.

	CreateKeyframeCatcher(animation)
		Returns a new KeyframeCatcher connected to `animation`, an AnimtionTrack.
	KeyframeCatcher:SetCallbacks(callbacks)
		`callbacks` can be a table of string/function pairs.
		When the AnimationTrack reaches a keyframe, the function corresponding to the keyframe's name will be called.
		Multiple functions can be invoked if the keyframe has multiple names, delimited by spaces, commas, or semi-colons.
		For example, a keyframe with the name "EndFlip StartKick" will call "EndFlip" and "StartKick" (in that order).
		`callbacks` can also be nil, which will disable the KeyframeCatcher.
]]
class'KeyframeCatcher'(function(def,animation)
	local reach

	function def:SetCallbacks(callbacks)
		if reach then
			reach:disconnect()
			reach = nil
		end
		if type(callbacks) == "table" then
			reach = animation.KeyframeReached:connect(function(keyframe)
				for name in keyframe:gmatch("[^,;%s]+") do
					local callback = callbacks[name]
					if callback then
						callback(animation)
					end
				end
			end)
		end
	end
end)

--[[----------------------------------------------------------------------------
AnimationProvider
	Manages animations.

	CreateAnimationProvider(animations)
		Returns a new AnimationProvider instance.
		`animations` is a table containing identity/asset_id pairs.
		`asset_id` may be a string (Content) or an integer.
	AnimationProvider:LoadHumanoid(humanoid)
		Loads the animations into `humanoid`.
	AnimationProvider:GetAnimation(identity)
		Returns an AnimationTrack.
		May only be called after LoadHumanoid.
	AnimationProvider:StopAnimations()
		Stops all animations.
		May only be called after LoadHumanoid.
	AnimationProvider:PrepareKeyframeCatcher(identity,callbacks)
		Prepares a KeyframeCatcher to load for `identity` once the hunmanoid loads.
]]
class'AnimationProvider'(function(def,anim_ids)
	local animations = {}
	local animationTracks = {}
	local catcherCallbacks = {}
	local keyframeCatchers = {}
	local workingHumanoid

	for name,id in pairs(anim_ids) do
		animations[name] = Create'Animation'{
			Name = name;
			AnimationId = type(id) == "number" and ("rbxassetid://"..id) or id;
			Archivable = false;
		}
	end

	function def:LoadHumanoid(humanoid)
		if humanoid ~= workingHumanoid then
			workingHumanoid = humanoid
			for name,anim in pairs(animations) do
				local old_track = animationTracks[name]
				if old_track then
					old_track:Stop()
					old_track:Destroy()
					if keyframeCatchers[name] then
						keyframeCatchers[name] = nil
					end
				end

				local track = humanoid:LoadAnimation(anim)
				animationTracks[name] = track
				if catcherCallbacks[name] then
					local catcher = CreateKeyframeCatcher(track)
					keyframeCatchers[name] = catcher
					catcher:SetCallbacks(catcherCallbacks[name])
				end
			end
		end
	end

	function def:GetAnimation(name)
		if not workingHumanoid then
			error("GetAnimation: humanoid has not been loaded",2)
		end
		return animationTracks[name]
	end

	function def:StopAnimations()
		for name,track in pairs(animationTracks) do
			track:Stop()
		end
	end

	function def:PrepareKeyframeCatcher(name,callbacks)
		catcherCallbacks[name] = callbacks
		if animationTracks[name] then
			local catcher = keyframeCatchers[name]
			if catcher then
				catcher:SetCallbacks(callbacks)
			elseif callbacks then
				catcher = CreateKeyframeCatcher(animationTrack[name])
				keyframeCatchers[name] = catcher
				catcher:SetCallbacks(catcherCallbacks[name])
			end
		end
	end

	-- lazy get
	setmetatable(def,{__index = animationTracks})
end)

class'SoundProvider'(function(def,sound_ids)
	local sounds = {}

	for name,id in pairs(sound_ids) do
		sounds[name] = Create'Sound'{
			Name = name;
			SoundId = type(id) == "number" and ("rbxassetid://"..id) or id;
			Archivable = false;
		}
	end

	function def:SetParent(parent)
		for name,sound in pairs(sounds) do
			sound.Parent = parent
		end
	end

	function def:GetSound(name)
		return sounds[name]
	end

	function def:StopSounds()
		for name,sound in pairs(sounds) do
			sound:Stop()
		end
	end

	-- lazy get
	setmetatable(def,{__index = sounds})
end)

--[[
ThreadID
	Makes sure new threads override old ones.

	CreateThreadID()
		Returns a new ThreadID.
	ThreadID:Request()
		Returns a new ID and increments the current one.
	ThreadID:Assert(id)
		Returns whether the thread's ID equals the current one.
	ThreadID:Reset()
		Reset the current ID.
]]
class'ThreadID'(function(def)
	local thread_id = 0

	function def:Assert(id)
		return thread_id == id
	end

	function def:Request()
		thread_id = thread_id + 1
		return thread_id
	end

	function def:Reset()
		thread_id = 0
	end
end)

--[[
BodyControl
	Non-Anchored control over a part.

	CreateBodyControl(part)
		Returns a new BodyControl wrapped around `part`, a BasePart.
	BodyControl:SetEnabled(enabled)
		Sets whether the BodyControl is enabled.
	BodyControl:SetCFrame(cframe)
		Sets the CFrame of the BodyControl (position and orientation).
]]
class'BodyControl'(function(def,object)
	local force_on = Vector3.new(math.huge,math.huge,math.huge)
	local force_off = Vector3.new()

	local BG = Instance.new("BodyGyro",object)
	BG.Archivable = false
	BG.D = 500
	BG.P = 100000
	BG.maxTorque = force_off

	local BP = Instance.new("BodyPosition",object)
	BP.Archivable = false
	BP.D = 500
	BP.P = 100000
	BP.maxForce = force_off

	function def:SetEnabled(enabled)
		BP.maxForce = enabled and force_on or force_off
		BG.maxTorque = enabled and force_on or force_off
	end

	function def:SetCFrame(cf)
		BP.position = cf.p
		BG.cframe = cf
	end
end)

--[[
	WalkSpeedManager
		Manages a Humanoid's WalkSpeed.
		When the walkspeed is set externally (not by this instance), the new value will become the base walkspeed.
		However, the walkspeed can be locked. If so, the walkspeed will be reverted if it has been changed externally.
		This allows the tool to be compatible with, say, a speed potion.

	CreateWalkSpeedManager()
		Returns a new WalkSpeedManager.
	WalkSpeedManager:SetHumanoid(humanoid)
		Sets the humanoid and sets its WalkSpeed as the base.
	WalkSpeedManager:Set(walkspeed)
		Sets and locks the humanoid's walkspeed.
	WalkSpeedManager:Reset()
		Unlocks and resets the humanoid's walkspeed to the base walkspeed.
	WalkSpeedManager:GetBase()
		Returns the base walkspeed.
]]
class'WalkSpeedManager'(function(def)
	local baseWalkSpeed = 16
	local currentWalkSpeed = 16
	local locked = false
	local settingInternal = false
	local humanoid
	local changed

	function def:SetHumanoid(hum)
		humanoid = hum
		locked = false
		if changed then changed:disconnect() end
		if hum then
			baseWalkSpeed = hum.WalkSpeed
			currentWalkSpeed = baseWalkSpeed
			changed = hum.Changed:connect(function(p)
				if p == "WalkSpeed" and not settingInternal then
					-- something external is modifying the walkspeed; use that as the base
					baseWalkSpeed = hum.WalkSpeed
					if locked then
						settingInternal = true
						hum.WalkSpeed = currentWalkSpeed
						settingInternal = false
					end
				end
			end)
		end
	end

	function def:Disconnect()
		if changed then changed:disconnect() changed=nil end
	end

	function def:Set(ws)
		if humanoid then
			locked = true
			currentWalkSpeed = ws
			settingInternal = true
			humanoid.WalkSpeed = ws
			settingInternal = false
		end
	end

	function def:Reset()
		if humanoid then
			currentWalkSpeed = baseWalkSpeed
			settingInternal = true
			humanoid.WalkSpeed = baseWalkSpeed
			settingInternal = false
			locked = false
		end
	end

	function def:GetBase()
		return baseWalkSpeed
	end
end)

--[[
	DamageManager
		Manages damage using a queue or something.

	CreateDamageManager()
		Returns a new DamageManager.
	DamageManager:SetDamageTable(table)
		Sets a table of name/damage pairs to use.
		The field [false] (as a bool) is the default damage if no damage is active.
		`damage` can be a number or a function that returns the damage.
	DamageManager:SetActive(name,active)
		Sets whether `name` is active.
	DamageManager:DeactivateAll()
		Deactivates all damage.
	DamageManager:GetDamage(...)
		Returns the current damage.
		If the current damage is a function, then received arguments are passed to that function.
]]
class'DamageManager'(function(def)
	local damageTable = {}
	local activeDamage = {false}	-- a table of damage fields that are active
	local damage = 0	-- the current active damage

	local function search_remove(t,k)
		local i = 1
		while i &lt;= #t do
			if t[i] == k then
				table.remove(t,i)
			else
				i = i + 1
			end
		end
	end

	function def:SetDamageTable(dt)
		damageTable = dt
		for i in pairs(activeDamage) do
			activeDamage[i] = nil
		end
		activeDamage[1] = false
		if not damageTable[false] then
			damageTable[false] = 0
		end
		damage = damageTable[false]
	end

	function def:SetActive(name,active)
		search_remove(activeDamage,name)
		if active then
			table.insert(activeDamage,1,name)
		end
		damage = damageTable[activeDamage[1]]
	end

	function def:DeactivateAll()
		for i in pairs(activeDamage) do
			activeDamage[i] = nil
		end
		activeDamage[1] = false
		damage = damageTable[false]
	end

	function def:GetDamage(...)
		if type(damage) == "function" then
			return damage(...)
		else
			return damage
		end
	end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- Tiny Event Manager; Add: [[Event.EventName = (event)]]; Remove: [[Disconnect("EventName",...)]]
local clicktime = 0
local Torso
local Event = {}
local function Disconnect(...)
	for _,name in pairs{...} do
		if Event[name] then
			Event[name]:disconnect()
			Event[name] = nil
		end
	end
end

-- get an object; make it if it doesn't exist
local function GetMake(parent,name,type)
	local object = parent:FindFirstChild(name)
	if not object then
		object = Create(type){Name=name}
		object.Parent = parent
	end
	return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
	while not parent:FindFirstChild(name) do
		parent.ChildAdded:wait()
	end
	return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
	if object and object.Parent then
		for i,v in pairs(object.Parent:GetChildren()) do
			if v:IsA"Humanoid" then
				return v
			end
		end
	end
	return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
	local humanoid = GetHumanoid(object)
	if humanoid then
		return object.Parent,humanoid
	end
	return nil
end

-- make a joint, if the objects exist
local PLEASE_STOP_EXISTING
local function AttemptJoint(x,y,c0,c1)
	if x and y then
		local weld = Instance.new("Motor6D")
		weld.Part0 = x
		weld.Part1 = y
		if c0 then weld.C0 = c0 end
		if c1 then weld.C1 = c1 end
		weld.Parent = x

		if x.Name == 'Right Arm' then
			PLEASE_STOP_EXISTING = weld
		end
	end
end

-- destroy a joint used only by the two objects
local function KillJoint(x,y)
	if x and y then
		for i,v in pairs(x:GetChildren()) do
			if v:IsA"Motor6D" then
				if v.Part0 == x and v.Part1 == y then
					v:Destroy()
				end
			end
		end
	end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Tool = script.Parent
local Handle = WaitForChild(Tool,"Handle")
local Character,Humanoid

local BurnScript = Tool:FindFirstChild("BurnScript")

local Damage = CreateDamageManager(Tool)
Damage:SetDamageTable{
	[false]			= 1;
	["Attack"]		= 20;
	["Spinning"]	= 0;
}

local spin_angle = 0.8
local max_spin_time = ( 3 )*30*spin_angle
local spin_slowdown = 1/4
local burn_ray_length = 8
local burn_chance = 1/6

local HandleControl = CreateBodyControl(Handle)
local WalkSpeed = CreateWalkSpeedManager()

local Animation = CreateAnimationProvider{
	Standing = "http://www.roblox.com/asset/?id=73177713";
	Swing = "http://www.roblox.com/asset/?id=73184276";
	Spin = "http://www.roblox.com/asset/?id=73177702";
}

local Sound = CreateSoundProvider{
	Swoosh = "http://www.roblox.com/asset/?id=46760716";
}
Sound:SetParent(Handle)
Sound.Swoosh.Volume = 0.25

local debugKeyframeReached = true

local Swinging = false
Animation:PrepareKeyframeCatcher("Swing",{
	AnimationStart = function() -- never fires
		debugKeyframeReached = false
		Swinging = true
	end;
	AnimationEnd = function()
		Swinging = false
	end;
	AttackStart = function()
		if Swinging then
			Damage:SetActive("Attack",true)
		end
	end;
	AttackEnd = function()
		Damage:SetActive("Attack",false)
	end;
	Swoosh = function()
		if Swinging then
			Sound.Swoosh.Pitch = math.random(120,123)/100
			Sound.Swoosh:Play()
		end
	end;
})

-- if theres a character, get a body part from it
local function GetBodyPart(name)
	local character = Character or GetCharacter(Tool)
	if character then
		local object = character:FindFirstChild(name)
		if object then
			return object
		end
	end
	return nil
end

-- sets fire on Handle to center or ends
local function SwitchFire(name,mult,active)
	local HandleFire = Tool:FindFirstChild(name)
	if HandleFire then
		local Fire = HandleFire:FindFirstChild("Fire")
		if Fire then
			if active then
				AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(math.pi,0,0))
				Fire.Heat = 25
				Fire.Size = 10
			else
				AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(math.pi/2*mult,0,0)*CFrame.new(0,0,3.5*mult))
				Fire.Heat = 9
				Fire.Size = 4
			end
		end
	end
end

-- casts a ray that will burn a player if it hits
local function CastBurnRay()
	if BurnScript then
		local HandleFire = Tool:FindFirstChild("HandleFireTop")
		if not HandleFire then
			HandleFire = Tool:FindFirstChild("HandleFireBottom")
		end
		if HandleFire then
			local cf = HandleFire.CFrame * CFrame.Angles(math.pi/2,0,0)
			local ch = GetCharacter(Tool)
			local Hit = Workspace:FindPartOnRay(Ray.new(cf.p,cf.lookVector*burn_ray_length),ch)
			if GetHumanoid(Hit) then
				local burn = BurnScript:Clone()
				burn.Disabled = false
				burn.Parent = Hit
			end
		end
	end
end

-- does the spinning animation
local SpinThread = CreateThreadID()
local function StartSpin(Torso)
	local id = SpinThread:Request()
	Animation.Spin:Play(0.25,1,1.5)
	Handle.CanCollide = false
	wait(0.25) -- eww
	if SpinThread:Assert(id) then
		Animation.Spin:Play(0,1,1.5) -- fixes bug
		Damage:SetActive("Spinning",true)
		Spinning.Value = true
		WalkSpeed:Set(WalkSpeed:GetBase()*spin_slowdown)
		KillJoint(GetBodyPart("Right Arm"),Handle)
		HandleControl:SetEnabled(true)
		SwitchFire("HandleFireTop",1,true)
		SwitchFire("HandleFireBottom",-1,true)
		local a = 0
		local s = 0
		local off = CFrame.new(0,0.5,-2) * CFrame.Angles(math.pi/2,0,0)
		while SpinThread:Assert(id) do
			HandleControl:SetCFrame(Torso.CFrame * off * CFrame.Angles(0,a,0))
			a = a + spin_angle
			s = s - 1
			if a &gt; max_spin_time then break end
			if s &lt;= 0 then
				s = 5
				Sound.Swoosh.Pitch = math.random(125,128)/100
				Sound.Swoosh:Play()
			end
			if math.random() &lt; burn_chance then
				CastBurnRay()
			end
			wait()
		end
	end
	Animation.Spin:Stop(0.25)
	SwitchFire("HandleFireTop",1,false)
	SwitchFire("HandleFireBottom",-1,false)
	HandleControl:SetEnabled(false)
	AttemptJoint(GetBodyPart("Right Arm"),Handle,CFrame.new(0,-1,0))
	WalkSpeed:Reset()
	Damage:SetActive("Spinning",false)
	Spinning.Value = false
	wait(0.25) -- eww
	Handle.CanCollide = true
end

Tool.Remote.OnServerEvent:connect(function(client, command, ...)
	if client.Character == Tool.Parent then
		if command == 'MB1Down' then
			local t = tick()
			if t-clicktime &lt; 0.2 then	-- double-click
				clicktime = t
				Animation.Swing:Stop(0)
				Swinging = false
				Damage:SetActive("Attack",false)
				StartSpin(Torso)
			else						-- single-click
				clicktime = t
				Swinging = true
				Animation.Swing:Play(0.1,1,1.25)
				if debugKeyframeReached then
					Sound.Swoosh.Pitch = math.random(120,123)/100
					Sound.Swoosh:Play()
				end
			end
		elseif command == 'MB1Up' then
			SpinThread:Request() --sloppy
			Animation.Swing:Stop(0.25)
			Swinging = false
			Damage:SetActive("Attack",false)
		end
	end
end)

local equipping = false
local unequipping = false
local unequippedCon
local unequippedFunc
Tool.Equipped:connect(function(Mouse) if equipping then return end equipping = true if unequipping then Tool.Parent = workspace end
	if not unequippedCon then
		unequippedCon = Tool.Unequipped:connect(unequippedFunc)
	end

	DamageBin = GetMake(Tool,"DamageBin","Configuration")
	Spinning = GetMake(Tool,"Spinning","BoolValue")

	if not Tool:FindFirstChild("HandleFireTop") then
		local HandleFire = Create'Part'{
			Name = "HandleFireTop";
			Parent = Tool;
			Archivable = false;
			Anchored = false;
			CanCollide = false;
			Locked = true;
			Transparency = 1;
			FormFactor = 0;
			Size = Vector3.new(1,1,1);
			TopSurface = 0;
			BottomSurface = 0;
			Create'Fire'{
				Color = Color3.new(246/255,69/255,0);
				SecondaryColor = Color3.new(102/255,0,102/255);
				Heat = 9;
				Size = 4;
			}
		}
		AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(math.pi/2,0,0)*CFrame.new(0,0,3.5))
	end

	if not Tool:FindFirstChild("HandleFireBottom") then
		local HandleFire = Create'Part'{
			Name = "HandleFireBottom";
			Archivable = false;
			Parent = Tool;
			Anchored = false;
			CanCollide = false;
			Locked = true;
			Transparency = 1;
			FormFactor = 0;
			Size = Vector3.new(1,1,1);
			TopSurface = 0;
			BottomSurface = 0;
			Create'Fire'{
				Color = Color3.new(1,0,0);
				SecondaryColor = Color3.new(179/255,0,182/255);
				Heat = 9;
				Size = 4;
			}
		}
		AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(-math.pi/2,0,0)*CFrame.new(0,0,-3.5))
	end


	Character,Humanoid = GetCharacter(Tool)
	if not Character then return end
	Animation:LoadHumanoid(Humanoid)
	WalkSpeed:SetHumanoid(Humanoid)
	clicktime = 0

	do	-- replace the interfering RightGrip joint
		local RightArm = GetBodyPart("Right Arm")
		if RightArm then
			WaitForChild(RightArm,"RightGrip")
			wait()
			AttemptJoint(RightArm,Handle,CFrame.new(0,-1,0))
		end
	end

	Animation.Standing:Play()

	Torso = GetBodyPart("Torso")

	Event.Died = Humanoid.Died:connect(function()
		SpinThread:Reset()
		Swinging = false
		Damage:SetActive("Attack",false)
	end)

	Event.Touched = Handle.Touched:connect(function(hit)
		if not hit:IsDescendantOf(Character) then
			local humanoid = GetHumanoid(hit)
			if humanoid then
				local dtag = Create'ObjectValue'{
					Name = tostring(Damage:GetDamage());
					Value = humanoid;
				}
				dtag.Parent = DamageBin
			end
		end
	end)

	wait(0.25) --ewww
	Handle.CanCollide = true

	equipping = false
end)

local lastTorsoCF
spawn(function()
	while true do
		if Character and Character:FindFirstChild'Torso' and not unequipping then
			lastTorsoCF = Character.Torso.CFrame
		end

		wait()
	end
end)

unequippedFunc = function() print'-a' if unequipping then return end unequipping = true if Tool.Parent:IsA'Workspace' then unequippedCon:disconnect() unequippedCon=nil end print'a'
	if Character and Character:FindFirstChild'Torso' then
		Character.Torso.CFrame = lastTorsoCF or (Character.Torso.CFrame - Vector3.new(0, 19202, 0))
	end

	local h2 = Handle:Clone()
	Handle:Destroy()
	Handle = h2
	Handle.Name = 'Handle'
	Handle.Velocity = Vector3.new()
	Handle.RotVelocity = Vector3.new()
	Handle.CFrame = CFrame.new(Character.Torso.CFrame * Vector3.new(0, 0, -8)) * CFrame.Angles(Handle.CFrame:toEulerAnglesXYZ())
	Handle.Parent = Tool
	print'b'
	if Tool:FindFirstChild'HandleFireTop' then Tool.HandleFireTop:Destroy() end
	if Tool:FindFirstChild'HandleFireBottom' then Tool.HandleFireBottom:Destroy() end
	if Tool:FindFirstChild'DamageBin' then Tool.DamageBin:Destroy() end
	if Tool:FindFirstChild'Spinning' then Tool.Spinning:Destroy() end

	WalkSpeed:Disconnect()

	Disconnect("Died","Touched")
	Animation:StopAnimations()
	KillJoint(Character and Character:FindFirstChild'Right Arm', Handle)
	Swinging = false
	Spinning.Value = false
	Damage:DeactivateAll()
	SpinThread:Reset()
	WalkSpeed:Reset()
	WalkSpeed:SetHumanoid()
	HandleControl:SetEnabled(false)
	print'c'
	delay(.5, function()
		Handle.Name = 'Handle'

		if Tool.Parent == workspace then
			local t2 = Tool:Clone()
			t2.Parent = workspace
			Tool:Destroy()
		end
	end)
	unequipping = false
end

unequippedCon = Tool.Unequipped:connect(unequippedFunc)</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="RemoteEvent" referent="RBX65C09B7502434E6994A9E009530687E1">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Remote</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
					</Properties>
				</Item>
				<Item class="Camera" referent="RBX46461A805FBA4073B9975BBC1D882316">
					<Properties>
						<BinaryString name="AttributesSerialize" />
						<CoordinateFrame name="CFrame">
							<X>1.02950513</X>
							<Y>30.0973587</Y>
							<Z>31.9825249</Z>
							<R00>0.144490883</R00>
							<R01>0.0239166766</R01>
							<R02>0.989217043</R02>
							<R10>-2.32830671e-10</R10>
							<R11>0.999707878</R11>
							<R12>-0.0241703149</R12>
							<R20>-0.989506185</R20>
							<R21>0.00349238981</R21>
							<R22>0.144448653</R22>
						</CoordinateFrame>
						<Ref name="CameraSubject">null</Ref>
						<token name="CameraType">0</token>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<float name="FieldOfView">70</float>
						<token name="FieldOfViewMode">0</token>
						<CoordinateFrame name="Focus">
							<X>-3.22307563</X>
							<Y>30.2012653</Y>
							<Z>31.3615494</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="HeadLocked">true</bool>
						<float name="HeadScale">1</float>
						<string name="Name">ThumbnailCamera</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags" />
						<bool name="VRTiltAndRollEnabled">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		